{"ast":null,"code":"'use strict';\n\nvar MqttClient = require('../client');\n\nvar Store = require('../store');\n\nvar url = require('url');\n\nvar xtend = require('xtend');\n\nvar protocols = {};\n\nif (process.title !== 'browser') {\n  protocols.mqtt = require('./tcp');\n  protocols.tcp = require('./tcp');\n  protocols.ssl = require('./tls');\n  protocols.tls = require('./tls');\n  protocols.mqtts = require('./tls');\n} else {\n  protocols.wx = require('./wx');\n  protocols.wxs = require('./wx');\n}\n\nprotocols.ws = require('./ws');\nprotocols.wss = require('./ws');\n/**\n * Parse the auth attribute and merge username and password in the options object.\n *\n * @param {Object} [opts] option object\n */\n\nfunction parseAuthOptions(opts) {\n  var matches;\n\n  if (opts.auth) {\n    matches = opts.auth.match(/^(.+):(.+)$/);\n\n    if (matches) {\n      opts.username = matches[1];\n      opts.password = matches[2];\n    } else {\n      opts.username = opts.auth;\n    }\n  }\n}\n/**\n * connect - connect to an MQTT broker.\n *\n * @param {String} [brokerUrl] - url of the broker, optional\n * @param {Object} opts - see MqttClient#constructor\n */\n\n\nfunction connect(brokerUrl, opts) {\n  if (typeof brokerUrl === 'object' && !opts) {\n    opts = brokerUrl;\n    brokerUrl = null;\n  }\n\n  opts = opts || {};\n\n  if (brokerUrl) {\n    var parsed = url.parse(brokerUrl, true);\n\n    if (parsed.port != null) {\n      parsed.port = Number(parsed.port);\n    }\n\n    opts = xtend(parsed, opts);\n\n    if (opts.protocol === null) {\n      throw new Error('Missing protocol');\n    }\n\n    opts.protocol = opts.protocol.replace(/:$/, '');\n  } // merge in the auth options if supplied\n\n\n  parseAuthOptions(opts); // support clientId passed in the query string of the url\n\n  if (opts.query && typeof opts.query.clientId === 'string') {\n    opts.clientId = opts.query.clientId;\n  }\n\n  if (opts.cert && opts.key) {\n    if (opts.protocol) {\n      if (['mqtts', 'wss', 'wxs'].indexOf(opts.protocol) === -1) {\n        switch (opts.protocol) {\n          case 'mqtt':\n            opts.protocol = 'mqtts';\n            break;\n\n          case 'ws':\n            opts.protocol = 'wss';\n            break;\n\n          case 'wx':\n            opts.protocol = 'wxs';\n            break;\n\n          default:\n            throw new Error('Unknown protocol for secure connection: \"' + opts.protocol + '\"!');\n        }\n      }\n    } else {\n      // don't know what protocol he want to use, mqtts or wss\n      throw new Error('Missing secure protocol key');\n    }\n  }\n\n  if (!protocols[opts.protocol]) {\n    var isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1;\n    opts.protocol = ['mqtt', 'mqtts', 'ws', 'wss', 'wx', 'wxs'].filter(function (key, index) {\n      if (isSecure && index % 2 === 0) {\n        // Skip insecure protocols when requesting a secure one.\n        return false;\n      }\n\n      return typeof protocols[key] === 'function';\n    })[0];\n  }\n\n  if (opts.clean === false && !opts.clientId) {\n    throw new Error('Missing clientId for unclean clients');\n  }\n\n  if (opts.protocol) {\n    opts.defaultProtocol = opts.protocol;\n  }\n\n  function wrapper(client) {\n    if (opts.servers) {\n      if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {\n        client._reconnectCount = 0;\n      }\n\n      opts.host = opts.servers[client._reconnectCount].host;\n      opts.port = opts.servers[client._reconnectCount].port;\n      opts.protocol = !opts.servers[client._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client._reconnectCount].protocol;\n      opts.hostname = opts.host;\n      client._reconnectCount++;\n    }\n\n    return protocols[opts.protocol](client, opts);\n  }\n\n  return new MqttClient(wrapper, opts);\n}\n\nmodule.exports = connect;\nmodule.exports.connect = connect;\nmodule.exports.MqttClient = MqttClient;\nmodule.exports.Store = Store;","map":null,"metadata":{},"sourceType":"script"}