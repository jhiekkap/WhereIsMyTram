{"ast":null,"code":"import _slicedToArray from \"/Users/jarihiekkapelto/Desktop/MOOC/harjoitusTyoFullStack19/mytram/ui/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/Users/jarihiekkapelto/Desktop/MOOC/harjoitusTyoFullStack19/mytram/ui/src/App.js\";\nimport React, { useEffect, useState } from 'react';\nimport { connect } from 'react-redux';\nimport { setTrams } from './reducers/tramsReducer';\nimport { setStops } from './reducers/stopsReducer';\nimport { setMyStop } from './reducers/myStopReducer';\nimport './App.css';\nimport LeafletMap from './components/LeafletMap';\nimport Sidebar from './components/Sidebar';\nimport client, { query } from './utils/client';\nimport { setShowTrams } from './reducers/showTramsReducer';\n\nconst App = ({\n  setTrams,\n  setStops,\n  setMyStop,\n  setShowTrams\n}) => {\n  const _useState = useState(true),\n        _useState2 = _slicedToArray(_useState, 2),\n        init = _useState2[0],\n        setInit = _useState2[1];\n\n  useEffect(() => {\n    client.query({\n      query\n    }).then(response => {\n      console.log('GRAPHQL - QUERY!');\n      let allStops = response.data.stopsByRadius.edges.map(edge => edge.node.stop).filter(stop => stop.vehicleType === 0);\n      setStops(allStops);\n      setMyStop(allStops[0]);\n    });\n  }, []);\n\n  const update = () => {\n    fetch('/trams').then(response => response.json()).then(body => {\n      setTrams(body);\n\n      if (init) {\n        setShowTrams(body);\n        setInit(false);\n      }\n    }).catch(error => {\n      console.log(error);\n    });\n  };\n\n  useState(() => {\n    setInterval(() => {\n      update();\n    }, 1000);\n  }, []);\n  return React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 54\n    },\n    __self: this\n  }, React.createElement(Sidebar, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 55\n    },\n    __self: this\n  }), React.createElement(LeafletMap, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 56\n    },\n    __self: this\n  }));\n};\n\nconst mapStateToProps = state => {\n  return {\n    settings: state.settings\n  };\n};\n\nconst mapDispatchToProps = {\n  setTrams,\n  setStops,\n  setMyStop,\n  setShowTrams\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(App); ////////// GEOLOCATION\n\n/*   if (\"geolocation\" in navigator) {\n      console.log(\"geolocation is available\");\n    } else {\n      console.log(\"geolocation is NOT available\");\n    }\n    navigator.geolocation.getCurrentPosition(position => { \n  \n      const query = gql`\n        {\n          stopsByRadius(lat: ${position.coords.latitude}, lon: ${position.coords.longitude}, radius: 1000) {\n            edges {\n              node {\n                stop {\n                  id\n                  gtfsId\n                   name\n                  lat\n                  lon \n                }\n              }\n            }\n          }\n        }\n        ` \n      client.query({ query })\n        .then((response) => {\n          let edges = response.data.stopsByRadius.edges\n          setStops(edges)\n          edges.forEach(edge => {\n            console.log('HSL: ', edge.node.stop)\n          })\n        })\n      console.log(\"STARTING LOCATION \\nlatitude: \" + position.coords.latitude + \" longitude: \" + position.coords.longitude);\n    }); */","map":{"version":3,"sources":["/Users/jarihiekkapelto/Desktop/MOOC/harjoitusTyoFullStack19/mytram/ui/src/App.js"],"names":["React","useEffect","useState","connect","setTrams","setStops","setMyStop","LeafletMap","Sidebar","client","query","setShowTrams","App","init","setInit","then","response","console","log","allStops","data","stopsByRadius","edges","map","edge","node","stop","filter","vehicleType","update","fetch","json","body","catch","error","setInterval","mapStateToProps","state","settings","mapDispatchToProps"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,QAA2C,OAA3C;AACA,SAASC,OAAT,QAAwB,aAAxB;AACA,SAASC,QAAT,QAAyB,yBAAzB;AACA,SAASC,QAAT,QAAyB,yBAAzB;AACA,SAASC,SAAT,QAA0B,0BAA1B;AACA,OAAO,WAAP;AACA,OAAOC,UAAP,MAAuB,yBAAvB;AACA,OAAOC,OAAP,MAAoB,sBAApB;AACA,OAAOC,MAAP,IAAiBC,KAAjB,QAA8B,gBAA9B;AACA,SAASC,YAAT,QAA6B,6BAA7B;;AAEA,MAAMC,GAAG,GAAG,CAAC;AACXR,EAAAA,QADW;AAEXC,EAAAA,QAFW;AAGXC,EAAAA,SAHW;AAIXK,EAAAA;AAJW,CAAD,KAKN;AAAA,oBAEoBT,QAAQ,CAAC,IAAD,CAF5B;AAAA;AAAA,QAEGW,IAFH;AAAA,QAESC,OAFT;;AAIJb,EAAAA,SAAS,CAAC,MAAM;AACdQ,IAAAA,MAAM,CAACC,KAAP,CAAa;AAAEA,MAAAA;AAAF,KAAb,EAAwBK,IAAxB,CAA6BC,QAAQ,IAAI;AACvCC,MAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ;AACA,UAAIC,QAAQ,GAAGH,QAAQ,CAACI,IAAT,CAAcC,aAAd,CAA4BC,KAA5B,CACZC,GADY,CACRC,IAAI,IAAIA,IAAI,CAACC,IAAL,CAAUC,IADV,EAEZC,MAFY,CAELD,IAAI,IAAIA,IAAI,CAACE,WAAL,KAAqB,CAFxB,CAAf;AAGAvB,MAAAA,QAAQ,CAACc,QAAD,CAAR;AACAb,MAAAA,SAAS,CAACa,QAAQ,CAAC,CAAD,CAAT,CAAT;AACD,KAPD;AAQD,GATQ,EASN,EATM,CAAT;;AAWA,QAAMU,MAAM,GAAG,MAAM;AACnBC,IAAAA,KAAK,CAAC,QAAD,CAAL,CACGf,IADH,CACQC,QAAQ,IAAIA,QAAQ,CAACe,IAAT,EADpB,EAEGhB,IAFH,CAEQiB,IAAI,IAAI;AACZ5B,MAAAA,QAAQ,CAAC4B,IAAD,CAAR;;AACA,UAAGnB,IAAH,EAAQ;AACNF,QAAAA,YAAY,CAACqB,IAAD,CAAZ;AACAlB,QAAAA,OAAO,CAAC,KAAD,CAAP;AACD;AACF,KARH,EASGmB,KATH,CASSC,KAAK,IAAI;AACdjB,MAAAA,OAAO,CAACC,GAAR,CAAYgB,KAAZ;AACD,KAXH;AAYD,GAbD;;AAeAhC,EAAAA,QAAQ,CAAC,MAAM;AACbiC,IAAAA,WAAW,CAAC,MAAM;AAChBN,MAAAA,MAAM;AACP,KAFU,EAER,IAFQ,CAAX;AAGD,GAJO,EAIL,EAJK,CAAR;AAMA,SACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACE,oBAAC,OAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IADF,EAEE,oBAAC,UAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAFF,CADF;AAMD,CA/CD;;AAiDA,MAAMO,eAAe,GAAGC,KAAK,IAAI;AAC/B,SAAO;AACLC,IAAAA,QAAQ,EAAED,KAAK,CAACC;AADX,GAAP;AAGD,CAJD;;AAMA,MAAMC,kBAAkB,GAAG;AACzBnC,EAAAA,QADyB;AAEzBC,EAAAA,QAFyB;AAGzBC,EAAAA,SAHyB;AAIzBK,EAAAA;AAJyB,CAA3B;AAOA,eAAeR,OAAO,CACpBiC,eADoB,EAEpBG,kBAFoB,CAAP,CAGb3B,GAHa,CAAf,C,CAKA;;AAEA","sourcesContent":["import React, { useEffect, useState } from 'react'\nimport { connect } from 'react-redux'\nimport { setTrams } from './reducers/tramsReducer' \nimport { setStops } from './reducers/stopsReducer'\nimport { setMyStop } from './reducers/myStopReducer' \nimport './App.css'\nimport LeafletMap from './components/LeafletMap'\nimport Sidebar from './components/Sidebar'\nimport client, { query } from './utils/client'\nimport { setShowTrams } from './reducers/showTramsReducer'\n\nconst App = ({\n  setTrams, \n  setStops,\n  setMyStop, \n  setShowTrams,\n}) => {\n\n  const [init, setInit] = useState(true)\n\n  useEffect(() => { \n    client.query({ query }).then(response => {\n      console.log('GRAPHQL - QUERY!') \n      let allStops = response.data.stopsByRadius.edges\n        .map(edge => edge.node.stop)\n        .filter(stop => stop.vehicleType === 0)\n      setStops(allStops)\n      setMyStop(allStops[0])\n    })\n  }, [])\n\n  const update = () => {\n    fetch('/trams')\n      .then(response => response.json())\n      .then(body => {\n        setTrams(body) \n        if(init){\n          setShowTrams(body)\n          setInit(false)\n        }\n      })\n      .catch(error => {\n        console.log(error)\n      })\n  }\n\n  useState(() => {\n    setInterval(() => {\n      update()  \n    }, 1000)\n  }, [])\n\n  return (\n    <div>\n      <Sidebar />\n      <LeafletMap />\n    </div>\n  )\n}\n\nconst mapStateToProps = state => {\n  return {\n    settings: state.settings,\n  }\n}\n\nconst mapDispatchToProps = {\n  setTrams,\n  setStops,\n  setMyStop, \n  setShowTrams\n}\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(App)\n\n////////// GEOLOCATION\n\n/*   if (\"geolocation\" in navigator) {\n      console.log(\"geolocation is available\");\n    } else {\n      console.log(\"geolocation is NOT available\");\n    }\n    navigator.geolocation.getCurrentPosition(position => { \n  \n      const query = gql`\n        {\n          stopsByRadius(lat: ${position.coords.latitude}, lon: ${position.coords.longitude}, radius: 1000) {\n            edges {\n              node {\n                stop {\n                  id\n                  gtfsId\n                   name\n                  lat\n                  lon \n                }\n              }\n            }\n          }\n        }\n        ` \n      client.query({ query })\n        .then((response) => {\n          let edges = response.data.stopsByRadius.edges\n          setStops(edges)\n          edges.forEach(edge => {\n            console.log('HSL: ', edge.node.stop)\n          })\n        })\n      console.log(\"STARTING LOCATION \\nlatitude: \" + position.coords.latitude + \" longitude: \" + position.coords.longitude);\n    }); */\n"]},"metadata":{},"sourceType":"module"}