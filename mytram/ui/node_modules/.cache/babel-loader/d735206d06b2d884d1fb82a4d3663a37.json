{"ast":null,"code":"/** @license\r\n *\r\n * SoundManager 2: JavaScript Sound for the Web\r\n * ----------------------------------------------\r\n * http://schillmania.com/projects/soundmanager2/\r\n *\r\n * Copyright (c) 2007, Scott Schiller. All rights reserved.\r\n * Code provided under the BSD License:\r\n * http://schillmania.com/projects/soundmanager2/license.txt\r\n *\r\n * V2.97a.20170601\r\n */\n\n/**\r\n * About this file\r\n * -------------------------------------------------------------------------------------\r\n * This is the fully-commented source version of the SoundManager 2 API,\r\n * recommended for use during development and testing.\r\n *\r\n * See soundmanager2-nodebug-jsmin.js for an optimized build (~11KB with gzip.)\r\n * http://schillmania.com/projects/soundmanager2/doc/getstarted/#basic-inclusion\r\n * Alternately, serve this file with gzip for 75% compression savings (~30KB over HTTP.)\r\n *\r\n * You may notice <d> and </d> comments in this source; these are delimiters for\r\n * debug blocks which are removed in the -nodebug builds, further optimizing code size.\r\n *\r\n * Also, as you may note: Whoa, reliable cross-platform/device audio support is hard! ;)\r\n */\n(function SM2(window, _undefined) {\n  /* global Audio, document, window, navigator, define, module, SM2_DEFER, opera, setTimeout, setInterval, clearTimeout, sm2Debugger */\n  'use strict';\n\n  if (!window || !window.document) {\n    // Don't cross the [environment] streams. SM2 expects to be running in a browser, not under node.js etc.\n    // Additionally, if a browser somehow manages to fail this test, as Egon said: \"It would be bad.\"\n    throw new Error('SoundManager requires a browser with window and document objects.');\n  }\n\n  var soundManager = null;\n  /**\r\n   * The SoundManager constructor.\r\n   *\r\n   * @constructor\r\n   * @param {string} smURL Optional: Path to SWF files\r\n   * @param {string} smID Optional: The ID to use for the SWF container element\r\n   * @this {SoundManager}\r\n   * @return {SoundManager} The new SoundManager instance\r\n   */\n\n  function SoundManager(smURL, smID) {\n    /**\r\n     * soundManager configuration options list\r\n     * defines top-level configuration properties to be applied to the soundManager instance (eg. soundManager.flashVersion)\r\n     * to set these properties, use the setup() method - eg., soundManager.setup({url: '/swf/', flashVersion: 9})\r\n     */\n    this.setupOptions = {\n      url: smURL || null,\n      // path (directory) where SoundManager 2 SWFs exist, eg., /path/to/swfs/\n      flashVersion: 8,\n      // flash build to use (8 or 9.) Some API features require 9.\n      debugMode: true,\n      // enable debugging output (console.log() with HTML fallback)\n      debugFlash: false,\n      // enable debugging output inside SWF, troubleshoot Flash/browser issues\n      useConsole: true,\n      // use console.log() if available (otherwise, writes to #soundmanager-debug element)\n      consoleOnly: true,\n      // if console is being used, do not create/write to #soundmanager-debug\n      waitForWindowLoad: false,\n      // force SM2 to wait for window.onload() before trying to call soundManager.onload()\n      bgColor: '#ffffff',\n      // SWF background color. N/A when wmode = 'transparent'\n      useHighPerformance: false,\n      // position:fixed flash movie can help increase js/flash speed, minimize lag\n      flashPollingInterval: null,\n      // msec affecting whileplaying/loading callback frequency. If null, default of 50 msec is used.\n      html5PollingInterval: null,\n      // msec affecting whileplaying() for HTML5 audio, excluding mobile devices. If null, native HTML5 update events are used.\n      flashLoadTimeout: 1000,\n      // msec to wait for flash movie to load before failing (0 = infinity)\n      wmode: null,\n      // flash rendering mode - null, 'transparent', or 'opaque' (last two allow z-index to work)\n      allowScriptAccess: 'always',\n      // for scripting the SWF (object/embed property), 'always' or 'sameDomain'\n      useFlashBlock: false,\n      // *requires flashblock.css, see demos* - allow recovery from flash blockers. Wait indefinitely and apply timeout CSS to SWF, if applicable.\n      useHTML5Audio: true,\n      // use HTML5 Audio() where API is supported (most Safari, Chrome versions), Firefox (MP3/MP4 support varies.) Ideally, transparent vs. Flash API where possible.\n      forceUseGlobalHTML5Audio: false,\n      // if true, a single Audio() object is used for all sounds - and only one can play at a time.\n      ignoreMobileRestrictions: false,\n      // if true, SM2 will not apply global HTML5 audio rules to mobile UAs. iOS > 7 and WebViews may allow multiple Audio() instances.\n      html5Test: /^(probably|maybe)$/i,\n      // HTML5 Audio() format support test. Use /^probably$/i; if you want to be more conservative.\n      preferFlash: false,\n      // overrides useHTML5audio, will use Flash for MP3/MP4/AAC if present. Potential option if HTML5 playback with these formats is quirky.\n      noSWFCache: false,\n      // if true, appends ?ts={date} to break aggressive SWF caching.\n      idPrefix: 'sound' // if an id is not provided to createSound(), this prefix is used for generated IDs - 'sound0', 'sound1' etc.\n\n    };\n    this.defaultOptions = {\n      /**\r\n       * the default configuration for sound objects made with createSound() and related methods\r\n       * eg., volume, auto-load behaviour and so forth\r\n       */\n      autoLoad: false,\n      // enable automatic loading (otherwise .load() will be called on demand with .play(), the latter being nicer on bandwidth - if you want to .load yourself, you also can)\n      autoPlay: false,\n      // enable playing of file as soon as possible (much faster if \"stream\" is true)\n      from: null,\n      // position to start playback within a sound (msec), default = beginning\n      loops: 1,\n      // how many times to repeat the sound (position will wrap around to 0, setPosition() will break out of loop when >0)\n      onid3: null,\n      // callback function for \"ID3 data is added/available\"\n      onerror: null,\n      // callback function for \"load failed\" (or, playback/network/decode error under HTML5.)\n      onload: null,\n      // callback function for \"load finished\"\n      whileloading: null,\n      // callback function for \"download progress update\" (X of Y bytes received)\n      onplay: null,\n      // callback for \"play\" start\n      onpause: null,\n      // callback for \"pause\"\n      onresume: null,\n      // callback for \"resume\" (pause toggle)\n      whileplaying: null,\n      // callback during play (position update)\n      onposition: null,\n      // object containing times and function callbacks for positions of interest\n      onstop: null,\n      // callback for \"user stop\"\n      onfinish: null,\n      // callback function for \"sound finished playing\"\n      multiShot: true,\n      // let sounds \"restart\" or layer on top of each other when played multiple times, rather than one-shot/one at a time\n      multiShotEvents: false,\n      // fire multiple sound events (currently onfinish() only) when multiShot is enabled\n      position: null,\n      // offset (milliseconds) to seek to within loaded sound data.\n      pan: 0,\n      // \"pan\" settings, left-to-right, -100 to 100\n      playbackRate: 1,\n      // rate at which to play the sound (HTML5-only)\n      stream: true,\n      // allows playing before entire file has loaded (recommended)\n      to: null,\n      // position to end playback within a sound (msec), default = end\n      type: null,\n      // MIME-like hint for file pattern / canPlay() tests, eg. audio/mp3\n      usePolicyFile: false,\n      // enable crossdomain.xml request for audio on remote domains (for ID3/waveform access)\n      volume: 100 // self-explanatory. 0-100, the latter being the max.\n\n    };\n    this.flash9Options = {\n      /**\r\n       * flash 9-only options,\r\n       * merged into defaultOptions if flash 9 is being used\r\n       */\n      onfailure: null,\n      // callback function for when playing fails (Flash 9, MovieStar + RTMP-only)\n      isMovieStar: null,\n      // \"MovieStar\" MPEG4 audio mode. Null (default) = auto detect MP4, AAC etc. based on URL. true = force on, ignore URL\n      usePeakData: false,\n      // enable left/right channel peak (level) data\n      useWaveformData: false,\n      // enable sound spectrum (raw waveform data) - NOTE: May increase CPU load.\n      useEQData: false,\n      // enable sound EQ (frequency spectrum data) - NOTE: May increase CPU load.\n      onbufferchange: null,\n      // callback for \"isBuffering\" property change\n      ondataerror: null // callback for waveform/eq data access error (flash playing audio in other tabs/domains)\n\n    };\n    this.movieStarOptions = {\n      /**\r\n       * flash 9.0r115+ MPEG4 audio options,\r\n       * merged into defaultOptions if flash 9+movieStar mode is enabled\r\n       */\n      bufferTime: 3,\n      // seconds of data to buffer before playback begins (null = flash default of 0.1 seconds - if AAC playback is gappy, try increasing.)\n      serverURL: null,\n      // rtmp: FMS or FMIS server to connect to, required when requesting media via RTMP or one of its variants\n      onconnect: null,\n      // rtmp: callback for connection to flash media server\n      duration: null // rtmp: song duration (msec)\n\n    };\n    this.audioFormats = {\n      /**\r\n       * determines HTML5 support + flash requirements.\r\n       * if no support (via flash and/or HTML5) for a \"required\" format, SM2 will fail to start.\r\n       * flash fallback is used for MP3 or MP4 if HTML5 can't play it (or if preferFlash = true)\r\n       */\n      mp3: {\n        type: ['audio/mpeg; codecs=\"mp3\"', 'audio/mpeg', 'audio/mp3', 'audio/MPA', 'audio/mpa-robust'],\n        required: true\n      },\n      mp4: {\n        related: ['aac', 'm4a', 'm4b'],\n        // additional formats under the MP4 container\n        type: ['audio/mp4; codecs=\"mp4a.40.2\"', 'audio/aac', 'audio/x-m4a', 'audio/MP4A-LATM', 'audio/mpeg4-generic'],\n        required: false\n      },\n      ogg: {\n        type: ['audio/ogg; codecs=vorbis'],\n        required: false\n      },\n      opus: {\n        type: ['audio/ogg; codecs=opus', 'audio/opus'],\n        required: false\n      },\n      wav: {\n        type: ['audio/wav; codecs=\"1\"', 'audio/wav', 'audio/wave', 'audio/x-wav'],\n        required: false\n      },\n      flac: {\n        type: ['audio/flac'],\n        required: false\n      }\n    }; // HTML attributes (id + class names) for the SWF container\n\n    this.movieID = 'sm2-container';\n    this.id = smID || 'sm2movie';\n    this.debugID = 'soundmanager-debug';\n    this.debugURLParam = /([#?&])debug=1/i; // dynamic attributes\n\n    this.versionNumber = 'V2.97a.20170601';\n    this.version = null;\n    this.movieURL = null;\n    this.altURL = null;\n    this.swfLoaded = false;\n    this.enabled = false;\n    this.oMC = null;\n    this.sounds = {};\n    this.soundIDs = [];\n    this.muted = false;\n    this.didFlashBlock = false;\n    this.filePattern = null;\n    this.filePatterns = {\n      flash8: /\\.mp3(\\?.*)?$/i,\n      flash9: /\\.mp3(\\?.*)?$/i\n    }; // support indicators, set at init\n\n    this.features = {\n      buffering: false,\n      peakData: false,\n      waveformData: false,\n      eqData: false,\n      movieStar: false\n    }; // flash sandbox info, used primarily in troubleshooting\n\n    this.sandbox = {\n      // <d>\n      type: null,\n      types: {\n        remote: 'remote (domain-based) rules',\n        localWithFile: 'local with file access (no internet access)',\n        localWithNetwork: 'local with network (internet access only, no local access)',\n        localTrusted: 'local, trusted (local+internet access)'\n      },\n      description: null,\n      noRemote: null,\n      noLocal: null // </d>\n\n    };\n    /**\r\n     * format support (html5/flash)\r\n     * stores canPlayType() results based on audioFormats.\r\n     * eg. { mp3: boolean, mp4: boolean }\r\n     * treat as read-only.\r\n     */\n\n    this.html5 = {\n      usingFlash: null // set if/when flash fallback is needed\n\n    }; // file type support hash\n\n    this.flash = {}; // determined at init time\n\n    this.html5Only = false; // used for special cases (eg. iPad/iPhone/palm OS?)\n\n    this.ignoreFlash = false;\n    /**\r\n     * a few private internals (OK, a lot. :D)\r\n     */\n\n    var SMSound,\n        sm2 = this,\n        globalHTML5Audio = null,\n        flash = null,\n        sm = 'soundManager',\n        smc = sm + ': ',\n        h5 = 'HTML5::',\n        id,\n        ua = navigator.userAgent,\n        wl = window.location.href.toString(),\n        doc = document,\n        doNothing,\n        setProperties,\n        init,\n        fV,\n        on_queue = [],\n        debugOpen = true,\n        debugTS,\n        didAppend = false,\n        appendSuccess = false,\n        didInit = false,\n        disabled = false,\n        windowLoaded = false,\n        _wDS,\n        wdCount = 0,\n        initComplete,\n        mixin,\n        assign,\n        extraOptions,\n        addOnEvent,\n        processOnEvents,\n        initUserOnload,\n        delayWaitForEI,\n        waitForEI,\n        rebootIntoHTML5,\n        setVersionInfo,\n        handleFocus,\n        strings,\n        initMovie,\n        domContentLoaded,\n        winOnLoad,\n        didDCLoaded,\n        getDocument,\n        createMovie,\n        catchError,\n        setPolling,\n        initDebug,\n        debugLevels = ['log', 'info', 'warn', 'error'],\n        defaultFlashVersion = 8,\n        disableObject,\n        failSafely,\n        normalizeMovieURL,\n        oRemoved = null,\n        oRemovedHTML = null,\n        str,\n        flashBlockHandler,\n        getSWFCSS,\n        swfCSS,\n        toggleDebug,\n        loopFix,\n        policyFix,\n        complain,\n        idCheck,\n        waitingForEI = false,\n        initPending = false,\n        startTimer,\n        stopTimer,\n        timerExecute,\n        h5TimerCount = 0,\n        h5IntervalTimer = null,\n        parseURL,\n        messages = [],\n        canIgnoreFlash,\n        needsFlash = null,\n        featureCheck,\n        html5OK,\n        html5CanPlay,\n        html5ErrorCodes,\n        html5Ext,\n        html5Unload,\n        domContentLoadedIE,\n        testHTML5,\n        event,\n        slice = Array.prototype.slice,\n        useGlobalHTML5Audio = false,\n        lastGlobalHTML5URL,\n        hasFlash,\n        detectFlash,\n        badSafariFix,\n        html5_events,\n        showSupport,\n        flushMessages,\n        wrapCallback,\n        idCounter = 0,\n        didSetup,\n        msecScale = 1000,\n        is_iDevice = ua.match(/(ipad|iphone|ipod)/i),\n        isAndroid = ua.match(/android/i),\n        isIE = ua.match(/msie|trident/i),\n        isWebkit = ua.match(/webkit/i),\n        isSafari = ua.match(/safari/i) && !ua.match(/chrome/i),\n        isOpera = ua.match(/opera/i),\n        mobileHTML5 = ua.match(/(mobile|pre\\/|xoom)/i) || is_iDevice || isAndroid,\n        isBadSafari = !wl.match(/usehtml5audio/i) && !wl.match(/sm2-ignorebadua/i) && isSafari && !ua.match(/silk/i) && ua.match(/OS\\sX\\s10_6_([3-7])/i),\n        // Safari 4 and 5 (excluding Kindle Fire, \"Silk\") occasionally fail to load/play HTML5 audio on Snow Leopard 10.6.3 through 10.6.7 due to bug(s) in QuickTime X and/or other underlying frameworks. :/ Confirmed bug. https://bugs.webkit.org/show_bug.cgi?id=32159\n    hasConsole = window.console !== _undefined && console.log !== _undefined,\n        isFocused = doc.hasFocus !== _undefined ? doc.hasFocus() : null,\n        tryInitOnFocus = isSafari && (doc.hasFocus === _undefined || !doc.hasFocus()),\n        okToDisable = !tryInitOnFocus,\n        flashMIME = /(mp3|mp4|mpa|m4a|m4b)/i,\n        emptyURL = 'about:blank',\n        // safe URL to unload, or load nothing from (flash 8 + most HTML5 UAs)\n    emptyWAV = 'data:audio/wave;base64,/UklGRiYAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQIAAAD//w==',\n        // tiny WAV for HTML5 unloading\n    overHTTP = doc.location ? doc.location.protocol.match(/http/i) : null,\n        http = !overHTTP ? '//' : '',\n        // mp3, mp4, aac etc.\n    netStreamMimeTypes = /^\\s*audio\\/(?:x-)?(?:mpeg4|aac|flv|mov|mp4|m4v|m4a|m4b|mp4v|3gp|3g2)\\s*(?:$|;)/i,\n        // Flash v9.0r115+ \"moviestar\" formats\n    netStreamTypes = ['mpeg4', 'aac', 'flv', 'mov', 'mp4', 'm4v', 'f4v', 'm4a', 'm4b', 'mp4v', '3gp', '3g2'],\n        netStreamPattern = new RegExp('\\\\.(' + netStreamTypes.join('|') + ')(\\\\?.*)?$', 'i');\n\n    this.mimePattern = /^\\s*audio\\/(?:x-)?(?:mp(?:eg|3))\\s*(?:$|;)/i; // default mp3 set\n    // use altURL if not \"online\"\n\n    this.useAltURL = !overHTTP;\n    swfCSS = {\n      swfBox: 'sm2-object-box',\n      swfDefault: 'movieContainer',\n      swfError: 'swf_error',\n      // SWF loaded, but SM2 couldn't start (other error)\n      swfTimedout: 'swf_timedout',\n      swfLoaded: 'swf_loaded',\n      swfUnblocked: 'swf_unblocked',\n      // or loaded OK\n      sm2Debug: 'sm2_debug',\n      highPerf: 'high_performance',\n      flashDebug: 'flash_debug'\n    };\n    /**\r\n     * HTML5 error codes, per W3C\r\n     * Error code 1, MEDIA_ERR_ABORTED: Client aborted download at user's request.\r\n     * Error code 2, MEDIA_ERR_NETWORK: A network error of some description caused the user agent to stop fetching the media resource, after the resource was established to be usable.\r\n     * Error code 3, MEDIA_ERR_DECODE: An error of some description occurred while decoding the media resource, after the resource was established to be usable.\r\n     * Error code 4, MEDIA_ERR_SRC_NOT_SUPPORTED: Media (audio file) not supported (\"not usable.\")\r\n     * Reference: https://html.spec.whatwg.org/multipage/embedded-content.html#error-codes\r\n     */\n\n    html5ErrorCodes = [null, 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED'];\n    /**\r\n     * basic HTML5 Audio() support test\r\n     * try...catch because of IE 9 \"not implemented\" nonsense\r\n     * https://github.com/Modernizr/Modernizr/issues/224\r\n     */\n\n    this.hasHTML5 = function () {\n      try {\n        // new Audio(null) for stupid Opera 9.64 case, which throws not_enough_arguments exception otherwise.\n        return Audio !== _undefined && (isOpera && opera !== _undefined && opera.version() < 10 ? new Audio(null) : new Audio()).canPlayType !== _undefined;\n      } catch (e) {\n        return false;\n      }\n    }();\n    /**\r\n     * Public SoundManager API\r\n     * -----------------------\r\n     */\n\n    /**\r\n     * Configures top-level soundManager properties.\r\n     *\r\n     * @param {object} options Option parameters, eg. { flashVersion: 9, url: '/path/to/swfs/' }\r\n     * onready and ontimeout are also accepted parameters. call soundManager.setup() to see the full list.\r\n     */\n\n\n    this.setup = function (options) {\n      var noURL = !sm2.url; // warn if flash options have already been applied\n\n      if (options !== _undefined && didInit && needsFlash && sm2.ok() && (options.flashVersion !== _undefined || options.url !== _undefined || options.html5Test !== _undefined)) {\n        complain(str('setupLate'));\n      } // TODO: defer: true?\n\n\n      assign(options);\n\n      if (!useGlobalHTML5Audio) {\n        if (mobileHTML5) {\n          // force the singleton HTML5 pattern on mobile, by default.\n          if (!sm2.setupOptions.ignoreMobileRestrictions || sm2.setupOptions.forceUseGlobalHTML5Audio) {\n            messages.push(strings.globalHTML5);\n            useGlobalHTML5Audio = true;\n          }\n        } else if (sm2.setupOptions.forceUseGlobalHTML5Audio) {\n          // only apply singleton HTML5 on desktop if forced.\n          messages.push(strings.globalHTML5);\n          useGlobalHTML5Audio = true;\n        }\n      }\n\n      if (!didSetup && mobileHTML5) {\n        if (sm2.setupOptions.ignoreMobileRestrictions) {\n          messages.push(strings.ignoreMobile);\n        } else {\n          // prefer HTML5 for mobile + tablet-like devices, probably more reliable vs. flash at this point.\n          // <d>\n          if (!sm2.setupOptions.useHTML5Audio || sm2.setupOptions.preferFlash) {\n            // notify that defaults are being changed.\n            sm2._wD(strings.mobileUA);\n          } // </d>\n\n\n          sm2.setupOptions.useHTML5Audio = true;\n          sm2.setupOptions.preferFlash = false;\n\n          if (is_iDevice) {\n            // no flash here.\n            sm2.ignoreFlash = true;\n          } else if (isAndroid && !ua.match(/android\\s2\\.3/i) || !isAndroid) {\n            /**\r\n             * Android devices tend to work better with a single audio instance, specifically for chained playback of sounds in sequence.\r\n             * Common use case: exiting sound onfinish() -> createSound() -> play()\r\n             * Presuming similar restrictions for other mobile, non-Android, non-iOS devices.\r\n             */\n            // <d>\n            sm2._wD(strings.globalHTML5); // </d>\n\n\n            useGlobalHTML5Audio = true;\n          }\n        }\n      } // special case 1: \"Late setup\". SM2 loaded normally, but user didn't assign flash URL eg., setup({url:...}) before SM2 init. Treat as delayed init.\n\n\n      if (options) {\n        if (noURL && didDCLoaded && options.url !== _undefined) {\n          sm2.beginDelayedInit();\n        } // special case 2: If lazy-loading SM2 (DOMContentLoaded has already happened) and user calls setup() with url: parameter, try to init ASAP.\n\n\n        if (!didDCLoaded && options.url !== _undefined && doc.readyState === 'complete') {\n          setTimeout(domContentLoaded, 1);\n        }\n      }\n\n      didSetup = true;\n      return sm2;\n    };\n\n    this.ok = function () {\n      return needsFlash ? didInit && !disabled : sm2.useHTML5Audio && sm2.hasHTML5;\n    };\n\n    this.supported = this.ok; // legacy\n\n    this.getMovie = function (movie_id) {\n      // safety net: some old browsers differ on SWF references, possibly related to ExternalInterface / flash version\n      return id(movie_id) || doc[movie_id] || window[movie_id];\n    };\n    /**\r\n     * Creates a SMSound sound object instance. Can also be overloaded, e.g., createSound('mySound', '/some.mp3');\r\n     *\r\n     * @param {object} oOptions Sound options (at minimum, url parameter is required.)\r\n     * @return {object} SMSound The new SMSound object.\r\n     */\n\n\n    this.createSound = function (oOptions, _url) {\n      var cs,\n          cs_string,\n          options,\n          oSound = null; // <d>\n\n      cs = sm + '.createSound(): ';\n      cs_string = cs + str(!didInit ? 'notReady' : 'notOK'); // </d>\n\n      if (!didInit || !sm2.ok()) {\n        complain(cs_string);\n        return false;\n      }\n\n      if (_url !== _undefined) {\n        // function overloading in JS! :) ... assume simple createSound(id, url) use case.\n        oOptions = {\n          id: oOptions,\n          url: _url\n        };\n      } // inherit from defaultOptions\n\n\n      options = mixin(oOptions);\n      options.url = parseURL(options.url); // generate an id, if needed.\n\n      if (options.id === _undefined) {\n        options.id = sm2.setupOptions.idPrefix + idCounter++;\n      } // <d>\n\n\n      if (options.id.toString().charAt(0).match(/^[0-9]$/)) {\n        sm2._wD(cs + str('badID', options.id), 2);\n      }\n\n      sm2._wD(cs + options.id + (options.url ? ' (' + options.url + ')' : ''), 1); // </d>\n\n\n      if (idCheck(options.id, true)) {\n        sm2._wD(cs + options.id + ' exists', 1);\n\n        return sm2.sounds[options.id];\n      }\n\n      function make() {\n        options = loopFix(options);\n        sm2.sounds[options.id] = new SMSound(options);\n        sm2.soundIDs.push(options.id);\n        return sm2.sounds[options.id];\n      }\n\n      if (html5OK(options)) {\n        oSound = make(); // <d>\n\n        if (!sm2.html5Only) {\n          sm2._wD(options.id + ': Using HTML5');\n        } // </d>\n\n\n        oSound._setup_html5(options);\n      } else {\n        if (sm2.html5Only) {\n          sm2._wD(options.id + ': No HTML5 support for this sound, and no Flash. Exiting.');\n\n          return make();\n        } // TODO: Move HTML5/flash checks into generic URL parsing/handling function.\n\n\n        if (sm2.html5.usingFlash && options.url && options.url.match(/data:/i)) {\n          // data: URIs not supported by Flash, either.\n          sm2._wD(options.id + ': data: URIs not supported via Flash. Exiting.');\n\n          return make();\n        }\n\n        if (fV > 8) {\n          if (options.isMovieStar === null) {\n            // attempt to detect MPEG-4 formats\n            options.isMovieStar = !!(options.serverURL || (options.type ? options.type.match(netStreamMimeTypes) : false) || options.url && options.url.match(netStreamPattern));\n          } // <d>\n\n\n          if (options.isMovieStar) {\n            sm2._wD(cs + 'using MovieStar handling');\n\n            if (options.loops > 1) {\n              _wDS('noNSLoop');\n            }\n          } // </d>\n\n        }\n\n        options = policyFix(options, cs);\n        oSound = make();\n\n        if (fV === 8) {\n          flash._createSound(options.id, options.loops || 1, options.usePolicyFile);\n        } else {\n          flash._createSound(options.id, options.url, options.usePeakData, options.useWaveformData, options.useEQData, options.isMovieStar, options.isMovieStar ? options.bufferTime : false, options.loops || 1, options.serverURL, options.duration || null, options.autoPlay, true, options.autoLoad, options.usePolicyFile);\n\n          if (!options.serverURL) {\n            // We are connected immediately\n            oSound.connected = true;\n\n            if (options.onconnect) {\n              options.onconnect.apply(oSound);\n            }\n          }\n        }\n\n        if (!options.serverURL && (options.autoLoad || options.autoPlay)) {\n          // call load for non-rtmp streams\n          oSound.load(options);\n        }\n      } // rtmp will play in onconnect\n\n\n      if (!options.serverURL && options.autoPlay) {\n        oSound.play();\n      }\n\n      return oSound;\n    };\n    /**\r\n     * Destroys a SMSound sound object instance.\r\n     *\r\n     * @param {string} sID The ID of the sound to destroy\r\n     */\n\n\n    this.destroySound = function (sID, _bFromSound) {\n      // explicitly destroy a sound before normal page unload, etc.\n      if (!idCheck(sID)) return false;\n      var oS = sm2.sounds[sID],\n          i;\n      oS.stop(); // Disable all callbacks after stop(), when the sound is being destroyed\n\n      oS._iO = {};\n      oS.unload();\n\n      for (i = 0; i < sm2.soundIDs.length; i++) {\n        if (sm2.soundIDs[i] === sID) {\n          sm2.soundIDs.splice(i, 1);\n          break;\n        }\n      }\n\n      if (!_bFromSound) {\n        // ignore if being called from SMSound instance\n        oS.destruct(true);\n      }\n\n      oS = null;\n      delete sm2.sounds[sID];\n      return true;\n    };\n    /**\r\n     * Calls the load() method of a SMSound object by ID.\r\n     *\r\n     * @param {string} sID The ID of the sound\r\n     * @param {object} oOptions Optional: Sound options\r\n     */\n\n\n    this.load = function (sID, oOptions) {\n      if (!idCheck(sID)) return false;\n      return sm2.sounds[sID].load(oOptions);\n    };\n    /**\r\n     * Calls the unload() method of a SMSound object by ID.\r\n     *\r\n     * @param {string} sID The ID of the sound\r\n     */\n\n\n    this.unload = function (sID) {\n      if (!idCheck(sID)) return false;\n      return sm2.sounds[sID].unload();\n    };\n    /**\r\n     * Calls the onPosition() method of a SMSound object by ID.\r\n     *\r\n     * @param {string} sID The ID of the sound\r\n     * @param {number} nPosition The position to watch for\r\n     * @param {function} oMethod The relevant callback to fire\r\n     * @param {object} oScope Optional: The scope to apply the callback to\r\n     * @return {SMSound} The SMSound object\r\n     */\n\n\n    this.onPosition = function (sID, nPosition, oMethod, oScope) {\n      if (!idCheck(sID)) return false;\n      return sm2.sounds[sID].onposition(nPosition, oMethod, oScope);\n    }; // legacy/backwards-compability: lower-case method name\n\n\n    this.onposition = this.onPosition;\n    /**\r\n     * Calls the clearOnPosition() method of a SMSound object by ID.\r\n     *\r\n     * @param {string} sID The ID of the sound\r\n     * @param {number} nPosition The position to watch for\r\n     * @param {function} oMethod Optional: The relevant callback to fire\r\n     * @return {SMSound} The SMSound object\r\n     */\n\n    this.clearOnPosition = function (sID, nPosition, oMethod) {\n      if (!idCheck(sID)) return false;\n      return sm2.sounds[sID].clearOnPosition(nPosition, oMethod);\n    };\n    /**\r\n     * Calls the play() method of a SMSound object by ID.\r\n     *\r\n     * @param {string} sID The ID of the sound\r\n     * @param {object} oOptions Optional: Sound options\r\n     * @return {SMSound} The SMSound object\r\n     */\n\n\n    this.play = function (sID, oOptions) {\n      var result = null,\n          // legacy function-overloading use case: play('mySound', '/path/to/some.mp3');\n      overloaded = oOptions && !(oOptions instanceof Object);\n\n      if (!didInit || !sm2.ok()) {\n        complain(sm + '.play(): ' + str(!didInit ? 'notReady' : 'notOK'));\n        return false;\n      }\n\n      if (!idCheck(sID, overloaded)) {\n        // no sound found for the given ID. Bail.\n        if (!overloaded) return false;\n\n        if (overloaded) {\n          oOptions = {\n            url: oOptions\n          };\n        }\n\n        if (oOptions && oOptions.url) {\n          // overloading use case, create+play: .play('someID', {url:'/path/to.mp3'});\n          sm2._wD(sm + '.play(): Attempting to create \"' + sID + '\"', 1);\n\n          oOptions.id = sID;\n          result = sm2.createSound(oOptions).play();\n        }\n      } else if (overloaded) {\n        // existing sound object case\n        oOptions = {\n          url: oOptions\n        };\n      }\n\n      if (result === null) {\n        // default case\n        result = sm2.sounds[sID].play(oOptions);\n      }\n\n      return result;\n    }; // just for convenience\n\n\n    this.start = this.play;\n    /**\r\n     * Calls the setPlaybackRate() method of a SMSound object by ID.\r\n     *\r\n     * @param {string} sID The ID of the sound\r\n     * @return {SMSound} The SMSound object\r\n     */\n\n    this.setPlaybackRate = function (sID, rate, allowOverride) {\n      if (!idCheck(sID)) return false;\n      return sm2.sounds[sID].setPlaybackRate(rate, allowOverride);\n    };\n    /**\r\n     * Calls the setPosition() method of a SMSound object by ID.\r\n     *\r\n     * @param {string} sID The ID of the sound\r\n     * @param {number} nMsecOffset Position (milliseconds)\r\n     * @return {SMSound} The SMSound object\r\n     */\n\n\n    this.setPosition = function (sID, nMsecOffset) {\n      if (!idCheck(sID)) return false;\n      return sm2.sounds[sID].setPosition(nMsecOffset);\n    };\n    /**\r\n     * Calls the stop() method of a SMSound object by ID.\r\n     *\r\n     * @param {string} sID The ID of the sound\r\n     * @return {SMSound} The SMSound object\r\n     */\n\n\n    this.stop = function (sID) {\n      if (!idCheck(sID)) return false;\n\n      sm2._wD(sm + '.stop(' + sID + ')', 1);\n\n      return sm2.sounds[sID].stop();\n    };\n    /**\r\n     * Stops all currently-playing sounds.\r\n     */\n\n\n    this.stopAll = function () {\n      var oSound;\n\n      sm2._wD(sm + '.stopAll()', 1);\n\n      for (oSound in sm2.sounds) {\n        if (sm2.sounds.hasOwnProperty(oSound)) {\n          // apply only to sound objects\n          sm2.sounds[oSound].stop();\n        }\n      }\n    };\n    /**\r\n     * Calls the pause() method of a SMSound object by ID.\r\n     *\r\n     * @param {string} sID The ID of the sound\r\n     * @return {SMSound} The SMSound object\r\n     */\n\n\n    this.pause = function (sID) {\n      if (!idCheck(sID)) return false;\n      return sm2.sounds[sID].pause();\n    };\n    /**\r\n     * Pauses all currently-playing sounds.\r\n     */\n\n\n    this.pauseAll = function () {\n      var i;\n\n      for (i = sm2.soundIDs.length - 1; i >= 0; i--) {\n        sm2.sounds[sm2.soundIDs[i]].pause();\n      }\n    };\n    /**\r\n     * Calls the resume() method of a SMSound object by ID.\r\n     *\r\n     * @param {string} sID The ID of the sound\r\n     * @return {SMSound} The SMSound object\r\n     */\n\n\n    this.resume = function (sID) {\n      if (!idCheck(sID)) return false;\n      return sm2.sounds[sID].resume();\n    };\n    /**\r\n     * Resumes all currently-paused sounds.\r\n     */\n\n\n    this.resumeAll = function () {\n      var i;\n\n      for (i = sm2.soundIDs.length - 1; i >= 0; i--) {\n        sm2.sounds[sm2.soundIDs[i]].resume();\n      }\n    };\n    /**\r\n     * Calls the togglePause() method of a SMSound object by ID.\r\n     *\r\n     * @param {string} sID The ID of the sound\r\n     * @return {SMSound} The SMSound object\r\n     */\n\n\n    this.togglePause = function (sID) {\n      if (!idCheck(sID)) return false;\n      return sm2.sounds[sID].togglePause();\n    };\n    /**\r\n     * Calls the setPan() method of a SMSound object by ID.\r\n     *\r\n     * @param {string} sID The ID of the sound\r\n     * @param {number} nPan The pan value (-100 to 100)\r\n     * @return {SMSound} The SMSound object\r\n     */\n\n\n    this.setPan = function (sID, nPan) {\n      if (!idCheck(sID)) return false;\n      return sm2.sounds[sID].setPan(nPan);\n    };\n    /**\r\n     * Calls the setVolume() method of a SMSound object by ID\r\n     * Overloaded case: pass only volume argument eg., setVolume(50) to apply to all sounds.\r\n     *\r\n     * @param {string} sID The ID of the sound\r\n     * @param {number} nVol The volume value (0 to 100)\r\n     * @return {SMSound} The SMSound object\r\n     */\n\n\n    this.setVolume = function (sID, nVol) {\n      // setVolume(50) function overloading case - apply to all sounds\n      var i, j;\n\n      if (sID !== _undefined && !isNaN(sID) && nVol === _undefined) {\n        for (i = 0, j = sm2.soundIDs.length; i < j; i++) {\n          sm2.sounds[sm2.soundIDs[i]].setVolume(sID);\n        }\n\n        return false;\n      } // setVolume('mySound', 50) case\n\n\n      if (!idCheck(sID)) return false;\n      return sm2.sounds[sID].setVolume(nVol);\n    };\n    /**\r\n     * Calls the mute() method of either a single SMSound object by ID, or all sound objects.\r\n     *\r\n     * @param {string} sID Optional: The ID of the sound (if omitted, all sounds will be used.)\r\n     */\n\n\n    this.mute = function (sID) {\n      var i = 0;\n\n      if (sID instanceof String) {\n        sID = null;\n      }\n\n      if (!sID) {\n        sm2._wD(sm + '.mute(): Muting all sounds');\n\n        for (i = sm2.soundIDs.length - 1; i >= 0; i--) {\n          sm2.sounds[sm2.soundIDs[i]].mute();\n        }\n\n        sm2.muted = true;\n      } else {\n        if (!idCheck(sID)) return false;\n\n        sm2._wD(sm + '.mute(): Muting \"' + sID + '\"');\n\n        return sm2.sounds[sID].mute();\n      }\n\n      return true;\n    };\n    /**\r\n     * Mutes all sounds.\r\n     */\n\n\n    this.muteAll = function () {\n      sm2.mute();\n    };\n    /**\r\n     * Calls the unmute() method of either a single SMSound object by ID, or all sound objects.\r\n     *\r\n     * @param {string} sID Optional: The ID of the sound (if omitted, all sounds will be used.)\r\n     */\n\n\n    this.unmute = function (sID) {\n      var i;\n\n      if (sID instanceof String) {\n        sID = null;\n      }\n\n      if (!sID) {\n        sm2._wD(sm + '.unmute(): Unmuting all sounds');\n\n        for (i = sm2.soundIDs.length - 1; i >= 0; i--) {\n          sm2.sounds[sm2.soundIDs[i]].unmute();\n        }\n\n        sm2.muted = false;\n      } else {\n        if (!idCheck(sID)) return false;\n\n        sm2._wD(sm + '.unmute(): Unmuting \"' + sID + '\"');\n\n        return sm2.sounds[sID].unmute();\n      }\n\n      return true;\n    };\n    /**\r\n     * Unmutes all sounds.\r\n     */\n\n\n    this.unmuteAll = function () {\n      sm2.unmute();\n    };\n    /**\r\n     * Calls the toggleMute() method of a SMSound object by ID.\r\n     *\r\n     * @param {string} sID The ID of the sound\r\n     * @return {SMSound} The SMSound object\r\n     */\n\n\n    this.toggleMute = function (sID) {\n      if (!idCheck(sID)) return false;\n      return sm2.sounds[sID].toggleMute();\n    };\n    /**\r\n     * Retrieves the memory used by the flash plugin.\r\n     *\r\n     * @return {number} The amount of memory in use\r\n     */\n\n\n    this.getMemoryUse = function () {\n      // flash-only\n      var ram = 0;\n\n      if (flash && fV !== 8) {\n        ram = parseInt(flash._getMemoryUse(), 10);\n      }\n\n      return ram;\n    };\n    /**\r\n     * Undocumented: NOPs soundManager and all SMSound objects.\r\n     */\n\n\n    this.disable = function (bNoDisable) {\n      // destroy all functions\n      var i;\n\n      if (bNoDisable === _undefined) {\n        bNoDisable = false;\n      } // already disabled?\n\n\n      if (disabled) return false;\n      disabled = true;\n\n      _wDS('shutdown', 1);\n\n      for (i = sm2.soundIDs.length - 1; i >= 0; i--) {\n        disableObject(sm2.sounds[sm2.soundIDs[i]]);\n      }\n\n      disableObject(sm2); // fire \"complete\", despite fail\n\n      initComplete(bNoDisable);\n      event.remove(window, 'load', initUserOnload);\n      return true;\n    };\n    /**\r\n     * Determines playability of a MIME type, eg. 'audio/mp3'.\r\n     */\n\n\n    this.canPlayMIME = function (sMIME) {\n      var result;\n\n      if (sm2.hasHTML5) {\n        result = html5CanPlay({\n          type: sMIME\n        });\n      }\n\n      if (!result && needsFlash) {\n        // if flash 9, test netStream (movieStar) types as well.\n        result = sMIME && sm2.ok() ? !!((fV > 8 ? sMIME.match(netStreamMimeTypes) : null) || sMIME.match(sm2.mimePattern)) : null; // TODO: make less \"weird\" (per JSLint)\n      }\n\n      return result;\n    };\n    /**\r\n     * Determines playability of a URL based on audio support.\r\n     *\r\n     * @param {string} sURL The URL to test\r\n     * @return {boolean} URL playability\r\n     */\n\n\n    this.canPlayURL = function (sURL) {\n      var result;\n\n      if (sm2.hasHTML5) {\n        result = html5CanPlay({\n          url: sURL\n        });\n      }\n\n      if (!result && needsFlash) {\n        result = sURL && sm2.ok() ? !!sURL.match(sm2.filePattern) : null;\n      }\n\n      return result;\n    };\n    /**\r\n     * Determines playability of an HTML DOM &lt;a&gt; object (or similar object literal) based on audio support.\r\n     *\r\n     * @param {object} oLink an HTML DOM &lt;a&gt; object or object literal including href and/or type attributes\r\n     * @return {boolean} URL playability\r\n     */\n\n\n    this.canPlayLink = function (oLink) {\n      if (oLink.type !== _undefined && oLink.type && sm2.canPlayMIME(oLink.type)) return true;\n      return sm2.canPlayURL(oLink.href);\n    };\n    /**\r\n     * Retrieves a SMSound object by ID.\r\n     *\r\n     * @param {string} sID The ID of the sound\r\n     * @return {SMSound} The SMSound object\r\n     */\n\n\n    this.getSoundById = function (sID, _suppressDebug) {\n      if (!sID) return null;\n      var result = sm2.sounds[sID]; // <d>\n\n      if (!result && !_suppressDebug) {\n        sm2._wD(sm + '.getSoundById(): Sound \"' + sID + '\" not found.', 2);\n      } // </d>\n\n\n      return result;\n    };\n    /**\r\n     * Queues a callback for execution when SoundManager has successfully initialized.\r\n     *\r\n     * @param {function} oMethod The callback method to fire\r\n     * @param {object} oScope Optional: The scope to apply to the callback\r\n     */\n\n\n    this.onready = function (oMethod, oScope) {\n      var sType = 'onready',\n          result = false;\n\n      if (typeof oMethod === 'function') {\n        // <d>\n        if (didInit) {\n          sm2._wD(str('queue', sType));\n        } // </d>\n\n\n        if (!oScope) {\n          oScope = window;\n        }\n\n        addOnEvent(sType, oMethod, oScope);\n        processOnEvents();\n        result = true;\n      } else {\n        throw str('needFunction', sType);\n      }\n\n      return result;\n    };\n    /**\r\n     * Queues a callback for execution when SoundManager has failed to initialize.\r\n     *\r\n     * @param {function} oMethod The callback method to fire\r\n     * @param {object} oScope Optional: The scope to apply to the callback\r\n     */\n\n\n    this.ontimeout = function (oMethod, oScope) {\n      var sType = 'ontimeout',\n          result = false;\n\n      if (typeof oMethod === 'function') {\n        // <d>\n        if (didInit) {\n          sm2._wD(str('queue', sType));\n        } // </d>\n\n\n        if (!oScope) {\n          oScope = window;\n        }\n\n        addOnEvent(sType, oMethod, oScope);\n        processOnEvents({\n          type: sType\n        });\n        result = true;\n      } else {\n        throw str('needFunction', sType);\n      }\n\n      return result;\n    };\n    /**\r\n     * Writes console.log()-style debug output to a console or in-browser element.\r\n     * Applies when debugMode = true\r\n     *\r\n     * @param {string} sText The console message\r\n     * @param {object} nType Optional log level (number), or object. Number case: Log type/style where 0 = 'info', 1 = 'warn', 2 = 'error'. Object case: Object to be dumped.\r\n     */\n\n\n    this._writeDebug = function (sText, sTypeOrObject) {\n      // pseudo-private console.log()-style output\n      // <d>\n      var sDID = 'soundmanager-debug',\n          o,\n          oItem;\n      if (!sm2.setupOptions.debugMode) return false;\n\n      if (hasConsole && sm2.useConsole) {\n        if (sTypeOrObject && typeof sTypeOrObject === 'object') {\n          // object passed; dump to console.\n          console.log(sText, sTypeOrObject);\n        } else if (debugLevels[sTypeOrObject] !== _undefined) {\n          console[debugLevels[sTypeOrObject]](sText);\n        } else {\n          console.log(sText);\n        }\n\n        if (sm2.consoleOnly) return true;\n      }\n\n      o = id(sDID);\n      if (!o) return false;\n      oItem = doc.createElement('div');\n\n      if (++wdCount % 2 === 0) {\n        oItem.className = 'sm2-alt';\n      }\n\n      if (sTypeOrObject === _undefined) {\n        sTypeOrObject = 0;\n      } else {\n        sTypeOrObject = parseInt(sTypeOrObject, 10);\n      }\n\n      oItem.appendChild(doc.createTextNode(sText));\n\n      if (sTypeOrObject) {\n        if (sTypeOrObject >= 2) {\n          oItem.style.fontWeight = 'bold';\n        }\n\n        if (sTypeOrObject === 3) {\n          oItem.style.color = '#ff3333';\n        }\n      } // top-to-bottom\n      // o.appendChild(oItem);\n      // bottom-to-top\n\n\n      o.insertBefore(oItem, o.firstChild);\n      o = null; // </d>\n\n      return true;\n    }; // <d>\n    // last-resort debugging option\n\n\n    if (wl.indexOf('sm2-debug=alert') !== -1) {\n      this._writeDebug = function (sText) {\n        window.alert(sText);\n      };\n    } // </d>\n    // alias\n\n\n    this._wD = this._writeDebug;\n    /**\r\n     * Provides debug / state information on all SMSound objects.\r\n     */\n\n    this._debug = function () {\n      // <d>\n      var i, j;\n\n      _wDS('currentObj', 1);\n\n      for (i = 0, j = sm2.soundIDs.length; i < j; i++) {\n        sm2.sounds[sm2.soundIDs[i]]._debug();\n      } // </d>\n\n    };\n    /**\r\n     * Restarts and re-initializes the SoundManager instance.\r\n     *\r\n     * @param {boolean} resetEvents Optional: When true, removes all registered onready and ontimeout event callbacks.\r\n     * @param {boolean} excludeInit Options: When true, does not call beginDelayedInit() (which would restart SM2).\r\n     * @return {object} soundManager The soundManager instance.\r\n     */\n\n\n    this.reboot = function (resetEvents, excludeInit) {\n      // reset some (or all) state, and re-init unless otherwise specified.\n      // <d>\n      if (sm2.soundIDs.length) {\n        sm2._wD('Destroying ' + sm2.soundIDs.length + ' SMSound object' + (sm2.soundIDs.length !== 1 ? 's' : '') + '...');\n      } // </d>\n\n\n      var i, j, k;\n\n      for (i = sm2.soundIDs.length - 1; i >= 0; i--) {\n        sm2.sounds[sm2.soundIDs[i]].destruct();\n      } // trash ze flash (remove from the DOM)\n\n\n      if (flash) {\n        try {\n          if (isIE) {\n            oRemovedHTML = flash.innerHTML;\n          }\n\n          oRemoved = flash.parentNode.removeChild(flash);\n        } catch (e) {\n          // Remove failed? May be due to flash blockers silently removing the SWF object/embed node from the DOM. Warn and continue.\n          _wDS('badRemove', 2);\n        }\n      } // actually, force recreate of movie.\n\n\n      oRemovedHTML = oRemoved = needsFlash = flash = null;\n      sm2.enabled = didDCLoaded = didInit = waitingForEI = initPending = didAppend = appendSuccess = disabled = useGlobalHTML5Audio = sm2.swfLoaded = false;\n      sm2.soundIDs = [];\n      sm2.sounds = {};\n      idCounter = 0;\n      didSetup = false;\n\n      if (!resetEvents) {\n        // reset callbacks for onready, ontimeout etc. so that they will fire again on re-init\n        for (i in on_queue) {\n          if (on_queue.hasOwnProperty(i)) {\n            for (j = 0, k = on_queue[i].length; j < k; j++) {\n              on_queue[i][j].fired = false;\n            }\n          }\n        }\n      } else {\n        // remove all callbacks entirely\n        on_queue = [];\n      } // <d>\n\n\n      if (!excludeInit) {\n        sm2._wD(sm + ': Rebooting...');\n      } // </d>\n      // reset HTML5 and flash canPlay test results\n\n\n      sm2.html5 = {\n        usingFlash: null\n      };\n      sm2.flash = {}; // reset device-specific HTML/flash mode switches\n\n      sm2.html5Only = false;\n      sm2.ignoreFlash = false;\n      window.setTimeout(function () {\n        // by default, re-init\n        if (!excludeInit) {\n          sm2.beginDelayedInit();\n        }\n      }, 20);\n      return sm2;\n    };\n\n    this.reset = function () {\n      /**\r\n       * Shuts down and restores the SoundManager instance to its original loaded state, without an explicit reboot. All onready/ontimeout handlers are removed.\r\n       * After this call, SM2 may be re-initialized via soundManager.beginDelayedInit().\r\n       * @return {object} soundManager The soundManager instance.\r\n       */\n      _wDS('reset');\n\n      return sm2.reboot(true, true);\n    };\n    /**\r\n     * Undocumented: Determines the SM2 flash movie's load progress.\r\n     *\r\n     * @return {number or null} Percent loaded, or if invalid/unsupported, null.\r\n     */\n\n\n    this.getMoviePercent = function () {\n      /**\r\n       * Interesting syntax notes...\r\n       * Flash/ExternalInterface (ActiveX/NPAPI) bridge methods are not typeof \"function\" nor instanceof Function, but are still valid.\r\n       * Furthermore, using (flash && flash.PercentLoaded) causes IE to throw \"object doesn't support this property or method\".\r\n       * Thus, 'in' syntax must be used.\r\n       */\n      return flash && 'PercentLoaded' in flash ? flash.PercentLoaded() : null;\n    };\n    /**\r\n     * Additional helper for manually invoking SM2's init process after DOM Ready / window.onload().\r\n     */\n\n\n    this.beginDelayedInit = function () {\n      windowLoaded = true;\n      domContentLoaded();\n      setTimeout(function () {\n        if (initPending) return false;\n        createMovie();\n        initMovie();\n        initPending = true;\n        return true;\n      }, 20);\n      delayWaitForEI();\n    };\n    /**\r\n     * Destroys the SoundManager instance and all SMSound instances.\r\n     */\n\n\n    this.destruct = function () {\n      sm2._wD(sm + '.destruct()');\n\n      sm2.disable(true);\n    };\n    /**\r\n     * SMSound() (sound object) constructor\r\n     * ------------------------------------\r\n     *\r\n     * @param {object} oOptions Sound options (id and url are required attributes)\r\n     * @return {SMSound} The new SMSound object\r\n     */\n\n\n    SMSound = function (oOptions) {\n      var s = this,\n          resetProperties,\n          add_html5_events,\n          remove_html5_events,\n          stop_html5_timer,\n          start_html5_timer,\n          attachOnPosition,\n          onplay_called = false,\n          onPositionItems = [],\n          onPositionFired = 0,\n          detachOnPosition,\n          applyFromTo,\n          lastURL = null,\n          lastHTML5State,\n          urlOmitted;\n      lastHTML5State = {\n        // tracks duration + position (time)\n        duration: null,\n        time: null\n      };\n      this.id = oOptions.id; // legacy\n\n      this.sID = this.id;\n      this.url = oOptions.url;\n      this.options = mixin(oOptions); // per-play-instance-specific options\n\n      this.instanceOptions = this.options; // short alias\n\n      this._iO = this.instanceOptions; // assign property defaults\n\n      this.pan = this.options.pan;\n      this.volume = this.options.volume; // whether or not this object is using HTML5\n\n      this.isHTML5 = false; // internal HTML5 Audio() object reference\n\n      this._a = null; // for flash 8 special-case createSound() without url, followed by load/play with url case\n\n      urlOmitted = !this.url;\n      /**\r\n       * SMSound() public methods\r\n       * ------------------------\r\n       */\n\n      this.id3 = {};\n      /**\r\n       * Writes SMSound object parameters to debug console\r\n       */\n\n      this._debug = function () {\n        // <d>\n        sm2._wD(s.id + ': Merged options:', s.options); // </d>\n\n      };\n      /**\r\n       * Begins loading a sound per its *url*.\r\n       *\r\n       * @param {object} options Optional: Sound options\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n\n      this.load = function (options) {\n        var oSound = null,\n            instanceOptions;\n\n        if (options !== _undefined) {\n          s._iO = mixin(options, s.options);\n        } else {\n          options = s.options;\n          s._iO = options;\n\n          if (lastURL && lastURL !== s.url) {\n            _wDS('manURL');\n\n            s._iO.url = s.url;\n            s.url = null;\n          }\n        }\n\n        if (!s._iO.url) {\n          s._iO.url = s.url;\n        }\n\n        s._iO.url = parseURL(s._iO.url); // ensure we're in sync\n\n        s.instanceOptions = s._iO; // local shortcut\n\n        instanceOptions = s._iO;\n\n        sm2._wD(s.id + ': load (' + instanceOptions.url + ')');\n\n        if (!instanceOptions.url && !s.url) {\n          sm2._wD(s.id + ': load(): url is unassigned. Exiting.', 2);\n\n          return s;\n        } // <d>\n\n\n        if (!s.isHTML5 && fV === 8 && !s.url && !instanceOptions.autoPlay) {\n          // flash 8 load() -> play() won't work before onload has fired.\n          sm2._wD(s.id + ': Flash 8 load() limitation: Wait for onload() before calling play().', 1);\n        } // </d>\n\n\n        if (instanceOptions.url === s.url && s.readyState !== 0 && s.readyState !== 2) {\n          _wDS('onURL', 1); // if loaded and an onload() exists, fire immediately.\n\n\n          if (s.readyState === 3 && instanceOptions.onload) {\n            // assume success based on truthy duration.\n            wrapCallback(s, function () {\n              instanceOptions.onload.apply(s, [!!s.duration]);\n            });\n          }\n\n          return s;\n        } // reset a few state properties\n\n\n        s.loaded = false;\n        s.readyState = 1;\n        s.playState = 0;\n        s.id3 = {}; // TODO: If switching from HTML5 -> flash (or vice versa), stop currently-playing audio.\n\n        if (html5OK(instanceOptions)) {\n          oSound = s._setup_html5(instanceOptions);\n\n          if (!oSound._called_load) {\n            s._html5_canplay = false; // TODO: review called_load / html5_canplay logic\n            // if url provided directly to load(), assign it here.\n\n            if (s.url !== instanceOptions.url) {\n              sm2._wD(_wDS('manURL') + ': ' + instanceOptions.url);\n\n              s._a.src = instanceOptions.url; // TODO: review / re-apply all relevant options (volume, loop, onposition etc.)\n              // reset position for new URL\n\n              s.setPosition(0);\n            } // given explicit load call, try to preload.\n            // early HTML5 implementation (non-standard)\n\n\n            s._a.autobuffer = 'auto'; // standard property, values: none / metadata / auto\n            // reference: http://msdn.microsoft.com/en-us/library/ie/ff974759%28v=vs.85%29.aspx\n\n            s._a.preload = 'auto';\n            s._a._called_load = true;\n          } else {\n            sm2._wD(s.id + ': Ignoring request to load again');\n          }\n        } else {\n          if (sm2.html5Only) {\n            sm2._wD(s.id + ': No flash support. Exiting.');\n\n            return s;\n          }\n\n          if (s._iO.url && s._iO.url.match(/data:/i)) {\n            // data: URIs not supported by Flash, either.\n            sm2._wD(s.id + ': data: URIs not supported via Flash. Exiting.');\n\n            return s;\n          }\n\n          try {\n            s.isHTML5 = false;\n            s._iO = policyFix(loopFix(instanceOptions)); // if we have \"position\", disable auto-play as we'll be seeking to that position at onload().\n\n            if (s._iO.autoPlay && (s._iO.position || s._iO.from)) {\n              sm2._wD(s.id + ': Disabling autoPlay because of non-zero offset case');\n\n              s._iO.autoPlay = false;\n            } // re-assign local shortcut\n\n\n            instanceOptions = s._iO;\n\n            if (fV === 8) {\n              flash._load(s.id, instanceOptions.url, instanceOptions.stream, instanceOptions.autoPlay, instanceOptions.usePolicyFile);\n            } else {\n              flash._load(s.id, instanceOptions.url, !!instanceOptions.stream, !!instanceOptions.autoPlay, instanceOptions.loops || 1, !!instanceOptions.autoLoad, instanceOptions.usePolicyFile);\n            }\n          } catch (e) {\n            _wDS('smError', 2);\n\n            debugTS('onload', false);\n            catchError({\n              type: 'SMSOUND_LOAD_JS_EXCEPTION',\n              fatal: true\n            });\n          }\n        } // after all of this, ensure sound url is up to date.\n\n\n        s.url = instanceOptions.url;\n        return s;\n      };\n      /**\r\n       * Unloads a sound, canceling any open HTTP requests.\r\n       *\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n\n      this.unload = function () {\n        // Flash 8/AS2 can't \"close\" a stream - fake it by loading an empty URL\n        // Flash 9/AS3: Close stream, preventing further load\n        // HTML5: Most UAs will use empty URL\n        if (s.readyState !== 0) {\n          sm2._wD(s.id + ': unload()');\n\n          if (!s.isHTML5) {\n            if (fV === 8) {\n              flash._unload(s.id, emptyURL);\n            } else {\n              flash._unload(s.id);\n            }\n          } else {\n            stop_html5_timer();\n\n            if (s._a) {\n              s._a.pause(); // update empty URL, too\n\n\n              lastURL = html5Unload(s._a);\n            }\n          } // reset load/status flags\n\n\n          resetProperties();\n        }\n\n        return s;\n      };\n      /**\r\n       * Unloads and destroys a sound.\r\n       */\n\n\n      this.destruct = function (_bFromSM) {\n        sm2._wD(s.id + ': Destruct');\n\n        if (!s.isHTML5) {\n          // kill sound within Flash\n          // Disable the onfailure handler\n          s._iO.onfailure = null;\n\n          flash._destroySound(s.id);\n        } else {\n          stop_html5_timer();\n\n          if (s._a) {\n            s._a.pause();\n\n            html5Unload(s._a);\n\n            if (!useGlobalHTML5Audio) {\n              remove_html5_events();\n            } // break obvious circular reference\n\n\n            s._a._s = null;\n            s._a = null;\n          }\n        }\n\n        if (!_bFromSM) {\n          // ensure deletion from controller\n          sm2.destroySound(s.id, true);\n        }\n      };\n      /**\r\n       * Begins playing a sound.\r\n       *\r\n       * @param {object} options Optional: Sound options\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n\n      this.play = function (options, _updatePlayState) {\n        var fN,\n            allowMulti,\n            a,\n            onready,\n            audioClone,\n            onended,\n            oncanplay,\n            startOK = true; // <d>\n\n        fN = s.id + ': play(): '; // </d>\n        // default to true\n\n        _updatePlayState = _updatePlayState === _undefined ? true : _updatePlayState;\n\n        if (!options) {\n          options = {};\n        } // first, use local URL (if specified)\n\n\n        if (s.url) {\n          s._iO.url = s.url;\n        } // mix in any options defined at createSound()\n\n\n        s._iO = mixin(s._iO, s.options); // mix in any options specific to this method\n\n        s._iO = mixin(options, s._iO);\n        s._iO.url = parseURL(s._iO.url);\n        s.instanceOptions = s._iO; // RTMP-only\n\n        if (!s.isHTML5 && s._iO.serverURL && !s.connected) {\n          if (!s.getAutoPlay()) {\n            sm2._wD(fN + ' Netstream not connected yet - setting autoPlay');\n\n            s.setAutoPlay(true);\n          } // play will be called in onconnect()\n\n\n          return s;\n        }\n\n        if (html5OK(s._iO)) {\n          s._setup_html5(s._iO);\n\n          start_html5_timer();\n        }\n\n        if (s.playState === 1 && !s.paused) {\n          allowMulti = s._iO.multiShot;\n\n          if (!allowMulti) {\n            sm2._wD(fN + 'Already playing (one-shot)', 1);\n\n            if (s.isHTML5) {\n              // go back to original position.\n              s.setPosition(s._iO.position);\n            }\n\n            return s;\n          }\n\n          sm2._wD(fN + 'Already playing (multi-shot)', 1);\n        } // edge case: play() with explicit URL parameter\n\n\n        if (options.url && options.url !== s.url) {\n          // special case for createSound() followed by load() / play() with url; avoid double-load case.\n          if (!s.readyState && !s.isHTML5 && fV === 8 && urlOmitted) {\n            urlOmitted = false;\n          } else {\n            // load using merged options\n            s.load(s._iO);\n          }\n        }\n\n        if (!s.loaded) {\n          if (s.readyState === 0) {\n            sm2._wD(fN + 'Attempting to load'); // try to get this sound playing ASAP\n\n\n            if (!s.isHTML5 && !sm2.html5Only) {\n              // flash: assign directly because setAutoPlay() increments the instanceCount\n              s._iO.autoPlay = true;\n              s.load(s._iO);\n            } else if (s.isHTML5) {\n              // iOS needs this when recycling sounds, loading a new URL on an existing object.\n              s.load(s._iO);\n            } else {\n              sm2._wD(fN + 'Unsupported type. Exiting.');\n\n              return s;\n            } // HTML5 hack - re-set instanceOptions?\n\n\n            s.instanceOptions = s._iO;\n          } else if (s.readyState === 2) {\n            sm2._wD(fN + 'Could not load - exiting', 2);\n\n            return s;\n          } else {\n            sm2._wD(fN + 'Loading - attempting to play...');\n          }\n        } else {\n          // \"play()\"\n          sm2._wD(fN.substr(0, fN.lastIndexOf(':')));\n        }\n\n        if (!s.isHTML5 && fV === 9 && s.position > 0 && s.position === s.duration) {\n          // flash 9 needs a position reset if play() is called while at the end of a sound.\n          sm2._wD(fN + 'Sound at end, resetting to position: 0');\n\n          options.position = 0;\n        }\n        /**\r\n         * Streams will pause when their buffer is full if they are being loaded.\r\n         * In this case paused is true, but the song hasn't started playing yet.\r\n         * If we just call resume() the onplay() callback will never be called.\r\n         * So only call resume() if the position is > 0.\r\n         * Another reason is because options like volume won't have been applied yet.\r\n         * For normal sounds, just resume.\r\n         */\n\n\n        if (s.paused && s.position >= 0 && (!s._iO.serverURL || s.position > 0)) {\n          // https://gist.github.com/37b17df75cc4d7a90bf6\n          sm2._wD(fN + 'Resuming from paused state', 1);\n\n          s.resume();\n        } else {\n          s._iO = mixin(options, s._iO);\n          /**\r\n           * Preload in the event of play() with position under Flash,\r\n           * or from/to parameters and non-RTMP case\r\n           */\n\n          if ((!s.isHTML5 && s._iO.position !== null && s._iO.position > 0 || s._iO.from !== null && s._iO.from > 0 || s._iO.to !== null) && s.instanceCount === 0 && s.playState === 0 && !s._iO.serverURL) {\n            onready = function () {\n              // sound \"canplay\" or onload()\n              // re-apply position/from/to to instance options, and start playback\n              s._iO = mixin(options, s._iO);\n              s.play(s._iO);\n            }; // HTML5 needs to at least have \"canplay\" fired before seeking.\n\n\n            if (s.isHTML5 && !s._html5_canplay) {\n              // this hasn't been loaded yet. load it first, and then do this again.\n              sm2._wD(fN + 'Beginning load for non-zero offset case');\n\n              s.load({\n                // note: custom HTML5-only event added for from/to implementation.\n                _oncanplay: onready\n              });\n            } else if (!s.isHTML5 && !s.loaded && (!s.readyState || s.readyState !== 2)) {\n              // to be safe, preload the whole thing in Flash.\n              sm2._wD(fN + 'Preloading for non-zero offset case');\n\n              s.load({\n                onload: onready\n              });\n            } // otherwise, we're ready to go. re-apply local options, and continue\n\n\n            s._iO = applyFromTo();\n          } // sm2._wD(fN + 'Starting to play');\n          // increment instance counter, where enabled + supported\n\n\n          if (!s.instanceCount || s._iO.multiShotEvents || s.isHTML5 && s._iO.multiShot && !useGlobalHTML5Audio || !s.isHTML5 && fV > 8 && !s.getAutoPlay()) {\n            s.instanceCount++;\n          } // if first play and onposition parameters exist, apply them now\n\n\n          if (s._iO.onposition && s.playState === 0) {\n            attachOnPosition(s);\n          }\n\n          s.playState = 1;\n          s.paused = false;\n          s.position = s._iO.position !== _undefined && !isNaN(s._iO.position) ? s._iO.position : 0;\n\n          if (!s.isHTML5) {\n            s._iO = policyFix(loopFix(s._iO));\n          }\n\n          if (s._iO.onplay && _updatePlayState) {\n            s._iO.onplay.apply(s);\n\n            onplay_called = true;\n          }\n\n          s.setVolume(s._iO.volume, true);\n          s.setPan(s._iO.pan, true);\n\n          if (s._iO.playbackRate !== 1) {\n            s.setPlaybackRate(s._iO.playbackRate);\n          }\n\n          if (!s.isHTML5) {\n            startOK = flash._start(s.id, s._iO.loops || 1, fV === 9 ? s.position : s.position / msecScale, s._iO.multiShot || false);\n\n            if (fV === 9 && !startOK) {\n              // edge case: no sound hardware, or 32-channel flash ceiling hit.\n              // applies only to Flash 9, non-NetStream/MovieStar sounds.\n              // http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/media/Sound.html#play%28%29\n              sm2._wD(fN + 'No sound hardware, or 32-sound ceiling hit', 2);\n\n              if (s._iO.onplayerror) {\n                s._iO.onplayerror.apply(s);\n              }\n            }\n          } else if (s.instanceCount < 2) {\n            // HTML5 single-instance case\n            start_html5_timer();\n            a = s._setup_html5();\n            s.setPosition(s._iO.position);\n            a.play();\n          } else {\n            // HTML5 multi-shot case\n            sm2._wD(s.id + ': Cloning Audio() for instance #' + s.instanceCount + '...');\n\n            audioClone = new Audio(s._iO.url);\n\n            onended = function () {\n              event.remove(audioClone, 'ended', onended);\n\n              s._onfinish(s); // cleanup\n\n\n              html5Unload(audioClone);\n              audioClone = null;\n            };\n\n            oncanplay = function () {\n              event.remove(audioClone, 'canplay', oncanplay);\n\n              try {\n                audioClone.currentTime = s._iO.position / msecScale;\n              } catch (err) {\n                complain(s.id + ': multiShot play() failed to apply position of ' + s._iO.position / msecScale);\n              }\n\n              audioClone.play();\n            };\n\n            event.add(audioClone, 'ended', onended); // apply volume to clones, too\n\n            if (s._iO.volume !== _undefined) {\n              audioClone.volume = Math.max(0, Math.min(1, s._iO.volume / 100));\n            } // playing multiple muted sounds? if you do this, you're weird ;) - but let's cover it.\n\n\n            if (s.muted) {\n              audioClone.muted = true;\n            }\n\n            if (s._iO.position) {\n              // HTML5 audio can't seek before onplay() event has fired.\n              // wait for canplay, then seek to position and start playback.\n              event.add(audioClone, 'canplay', oncanplay);\n            } else {\n              // begin playback at currentTime: 0\n              audioClone.play();\n            }\n          }\n        }\n\n        return s;\n      }; // just for convenience\n\n\n      this.start = this.play;\n      /**\r\n       * Stops playing a sound (and optionally, all sounds)\r\n       *\r\n       * @param {boolean} bAll Optional: Whether to stop all sounds\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n      this.stop = function (bAll) {\n        var instanceOptions = s._iO,\n            originalPosition;\n\n        if (s.playState === 1) {\n          sm2._wD(s.id + ': stop()');\n\n          s._onbufferchange(0);\n\n          s._resetOnPosition(0);\n\n          s.paused = false;\n\n          if (!s.isHTML5) {\n            s.playState = 0;\n          } // remove onPosition listeners, if any\n\n\n          detachOnPosition(); // and \"to\" position, if set\n\n          if (instanceOptions.to) {\n            s.clearOnPosition(instanceOptions.to);\n          }\n\n          if (!s.isHTML5) {\n            flash._stop(s.id, bAll); // hack for netStream: just unload\n\n\n            if (instanceOptions.serverURL) {\n              s.unload();\n            }\n          } else if (s._a) {\n            originalPosition = s.position; // act like Flash, though\n\n            s.setPosition(0); // hack: reflect old position for onstop() (also like Flash)\n\n            s.position = originalPosition; // html5 has no stop()\n            // NOTE: pausing means iOS requires interaction to resume.\n\n            s._a.pause();\n\n            s.playState = 0; // and update UI\n\n            s._onTimer();\n\n            stop_html5_timer();\n          }\n\n          s.instanceCount = 0;\n          s._iO = {};\n\n          if (instanceOptions.onstop) {\n            instanceOptions.onstop.apply(s);\n          }\n        }\n\n        return s;\n      };\n      /**\r\n       * Undocumented/internal: Sets autoPlay for RTMP.\r\n       *\r\n       * @param {boolean} autoPlay state\r\n       */\n\n\n      this.setAutoPlay = function (autoPlay) {\n        sm2._wD(s.id + ': Autoplay turned ' + (autoPlay ? 'on' : 'off'));\n\n        s._iO.autoPlay = autoPlay;\n\n        if (!s.isHTML5) {\n          flash._setAutoPlay(s.id, autoPlay);\n\n          if (autoPlay) {\n            // only increment the instanceCount if the sound isn't loaded (TODO: verify RTMP)\n            if (!s.instanceCount && s.readyState === 1) {\n              s.instanceCount++;\n\n              sm2._wD(s.id + ': Incremented instance count to ' + s.instanceCount);\n            }\n          }\n        }\n      };\n      /**\r\n       * Undocumented/internal: Returns the autoPlay boolean.\r\n       *\r\n       * @return {boolean} The current autoPlay value\r\n       */\n\n\n      this.getAutoPlay = function () {\n        return s._iO.autoPlay;\n      };\n      /**\r\n       * Sets the playback rate of a sound (HTML5-only.)\r\n       *\r\n       * @param {number} playbackRate (+/-)\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n\n      this.setPlaybackRate = function (playbackRate) {\n        // Per Mozilla, limit acceptable values to prevent playback from stopping (unless allowOverride is truthy.)\n        // https://developer.mozilla.org/en-US/Apps/Build/Audio_and_video_delivery/WebAudio_playbackRate_explained\n        var normalizedRate = Math.max(0.5, Math.min(4, playbackRate)); // <d>\n\n        if (normalizedRate !== playbackRate) {\n          sm2._wD(s.id + ': setPlaybackRate(' + playbackRate + '): limiting rate to ' + normalizedRate, 2);\n        } // </d>\n\n\n        if (s.isHTML5) {\n          try {\n            s._iO.playbackRate = normalizedRate;\n            s._a.playbackRate = normalizedRate;\n          } catch (e) {\n            sm2._wD(s.id + ': setPlaybackRate(' + normalizedRate + ') failed: ' + e.message, 2);\n          }\n        }\n\n        return s;\n      };\n      /**\r\n       * Sets the position of a sound.\r\n       *\r\n       * @param {number} nMsecOffset Position (milliseconds)\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n\n      this.setPosition = function (nMsecOffset) {\n        if (nMsecOffset === _undefined) {\n          nMsecOffset = 0;\n        }\n\n        var position,\n            position1K,\n            // Use the duration from the instance options, if we don't have a track duration yet.\n        // position >= 0 and <= current available (loaded) duration\n        offset = s.isHTML5 ? Math.max(nMsecOffset, 0) : Math.min(s.duration || s._iO.duration, Math.max(nMsecOffset, 0));\n        s.position = offset;\n        position1K = s.position / msecScale;\n\n        s._resetOnPosition(s.position);\n\n        s._iO.position = offset;\n\n        if (!s.isHTML5) {\n          position = fV === 9 ? s.position : position1K;\n\n          if (s.readyState && s.readyState !== 2) {\n            // if paused or not playing, will not resume (by playing)\n            flash._setPosition(s.id, position, s.paused || !s.playState, s._iO.multiShot);\n          }\n        } else if (s._a) {\n          // Set the position in the canplay handler if the sound is not ready yet\n          if (s._html5_canplay) {\n            if (s._a.currentTime.toFixed(3) !== position1K.toFixed(3)) {\n              /**\r\n               * DOM/JS errors/exceptions to watch out for:\r\n               * if seek is beyond (loaded?) position, \"DOM exception 11\"\r\n               * \"INDEX_SIZE_ERR\": DOM exception 1\r\n               */\n              sm2._wD(s.id + ': setPosition(' + position1K + ')');\n\n              try {\n                s._a.currentTime = position1K;\n\n                if (s.playState === 0 || s.paused) {\n                  // allow seek without auto-play/resume\n                  s._a.pause();\n                }\n              } catch (e) {\n                sm2._wD(s.id + ': setPosition(' + position1K + ') failed: ' + e.message, 2);\n              }\n            }\n          } else if (position1K) {\n            // warn on non-zero seek attempts\n            sm2._wD(s.id + ': setPosition(' + position1K + '): Cannot seek yet, sound not ready', 2);\n\n            return s;\n          }\n\n          if (s.paused) {\n            // if paused, refresh UI right away by forcing update\n            s._onTimer(true);\n          }\n        }\n\n        return s;\n      };\n      /**\r\n       * Pauses sound playback.\r\n       *\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n\n      this.pause = function (_bCallFlash) {\n        if (s.paused || s.playState === 0 && s.readyState !== 1) return s;\n\n        sm2._wD(s.id + ': pause()');\n\n        s.paused = true;\n\n        if (!s.isHTML5) {\n          if (_bCallFlash || _bCallFlash === _undefined) {\n            flash._pause(s.id, s._iO.multiShot);\n          }\n        } else {\n          s._setup_html5().pause();\n\n          stop_html5_timer();\n        }\n\n        if (s._iO.onpause) {\n          s._iO.onpause.apply(s);\n        }\n\n        return s;\n      };\n      /**\r\n       * Resumes sound playback.\r\n       *\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n      /**\r\n       * When auto-loaded streams pause on buffer full they have a playState of 0.\r\n       * We need to make sure that the playState is set to 1 when these streams \"resume\".\r\n       * When a paused stream is resumed, we need to trigger the onplay() callback if it\r\n       * hasn't been called already. In this case since the sound is being played for the\r\n       * first time, I think it's more appropriate to call onplay() rather than onresume().\r\n       */\n\n\n      this.resume = function () {\n        var instanceOptions = s._iO;\n        if (!s.paused) return s;\n\n        sm2._wD(s.id + ': resume()');\n\n        s.paused = false;\n        s.playState = 1;\n\n        if (!s.isHTML5) {\n          if (instanceOptions.isMovieStar && !instanceOptions.serverURL) {\n            // Bizarre Webkit bug (Chrome reported via 8tracks.com dudes): AAC content paused for 30+ seconds(?) will not resume without a reposition.\n            s.setPosition(s.position);\n          } // flash method is toggle-based (pause/resume)\n\n\n          flash._pause(s.id, instanceOptions.multiShot);\n        } else {\n          s._setup_html5().play();\n\n          start_html5_timer();\n        }\n\n        if (!onplay_called && instanceOptions.onplay) {\n          instanceOptions.onplay.apply(s);\n          onplay_called = true;\n        } else if (instanceOptions.onresume) {\n          instanceOptions.onresume.apply(s);\n        }\n\n        return s;\n      };\n      /**\r\n       * Toggles sound playback.\r\n       *\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n\n      this.togglePause = function () {\n        sm2._wD(s.id + ': togglePause()');\n\n        if (s.playState === 0) {\n          s.play({\n            position: fV === 9 && !s.isHTML5 ? s.position : s.position / msecScale\n          });\n          return s;\n        }\n\n        if (s.paused) {\n          s.resume();\n        } else {\n          s.pause();\n        }\n\n        return s;\n      };\n      /**\r\n       * Sets the panning (L-R) effect.\r\n       *\r\n       * @param {number} nPan The pan value (-100 to 100)\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n\n      this.setPan = function (nPan, bInstanceOnly) {\n        if (nPan === _undefined) {\n          nPan = 0;\n        }\n\n        if (bInstanceOnly === _undefined) {\n          bInstanceOnly = false;\n        }\n\n        if (!s.isHTML5) {\n          flash._setPan(s.id, nPan);\n        } // else { no HTML5 pan? }\n\n\n        s._iO.pan = nPan;\n\n        if (!bInstanceOnly) {\n          s.pan = nPan;\n          s.options.pan = nPan;\n        }\n\n        return s;\n      };\n      /**\r\n       * Sets the volume.\r\n       *\r\n       * @param {number} nVol The volume value (0 to 100)\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n\n      this.setVolume = function (nVol, _bInstanceOnly) {\n        /**\r\n         * Note: Setting volume has no effect on iOS \"special snowflake\" devices.\r\n         * Hardware volume control overrides software, and volume\r\n         * will always return 1 per Apple docs. (iOS 4 + 5.)\r\n         * http://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/AddingSoundtoCanvasAnimations/AddingSoundtoCanvasAnimations.html\r\n         */\n        if (nVol === _undefined) {\n          nVol = 100;\n        }\n\n        if (_bInstanceOnly === _undefined) {\n          _bInstanceOnly = false;\n        }\n\n        if (!s.isHTML5) {\n          flash._setVolume(s.id, sm2.muted && !s.muted || s.muted ? 0 : nVol);\n        } else if (s._a) {\n          if (sm2.muted && !s.muted) {\n            s.muted = true;\n            s._a.muted = true;\n          } // valid range for native HTML5 Audio(): 0-1\n\n\n          s._a.volume = Math.max(0, Math.min(1, nVol / 100));\n        }\n\n        s._iO.volume = nVol;\n\n        if (!_bInstanceOnly) {\n          s.volume = nVol;\n          s.options.volume = nVol;\n        }\n\n        return s;\n      };\n      /**\r\n       * Mutes the sound.\r\n       *\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n\n      this.mute = function () {\n        s.muted = true;\n\n        if (!s.isHTML5) {\n          flash._setVolume(s.id, 0);\n        } else if (s._a) {\n          s._a.muted = true;\n        }\n\n        return s;\n      };\n      /**\r\n       * Unmutes the sound.\r\n       *\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n\n      this.unmute = function () {\n        s.muted = false;\n        var hasIO = s._iO.volume !== _undefined;\n\n        if (!s.isHTML5) {\n          flash._setVolume(s.id, hasIO ? s._iO.volume : s.options.volume);\n        } else if (s._a) {\n          s._a.muted = false;\n        }\n\n        return s;\n      };\n      /**\r\n       * Toggles the muted state of a sound.\r\n       *\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n\n      this.toggleMute = function () {\n        return s.muted ? s.unmute() : s.mute();\n      };\n      /**\r\n       * Registers a callback to be fired when a sound reaches a given position during playback.\r\n       *\r\n       * @param {number} nPosition The position to watch for\r\n       * @param {function} oMethod The relevant callback to fire\r\n       * @param {object} oScope Optional: The scope to apply the callback to\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n\n      this.onPosition = function (nPosition, oMethod, oScope) {\n        // TODO: basic dupe checking?\n        onPositionItems.push({\n          position: parseInt(nPosition, 10),\n          method: oMethod,\n          scope: oScope !== _undefined ? oScope : s,\n          fired: false\n        });\n        return s;\n      }; // legacy/backwards-compability: lower-case method name\n\n\n      this.onposition = this.onPosition;\n      /**\r\n       * Removes registered callback(s) from a sound, by position and/or callback.\r\n       *\r\n       * @param {number} nPosition The position to clear callback(s) for\r\n       * @param {function} oMethod Optional: Identify one callback to be removed when multiple listeners exist for one position\r\n       * @return {SMSound} The SMSound object\r\n       */\n\n      this.clearOnPosition = function (nPosition, oMethod) {\n        var i;\n        nPosition = parseInt(nPosition, 10);\n\n        if (isNaN(nPosition)) {\n          // safety check\n          return;\n        }\n\n        for (i = 0; i < onPositionItems.length; i++) {\n          if (nPosition === onPositionItems[i].position) {\n            // remove this item if no method was specified, or, if the method matches\n            if (!oMethod || oMethod === onPositionItems[i].method) {\n              if (onPositionItems[i].fired) {\n                // decrement \"fired\" counter, too\n                onPositionFired--;\n              }\n\n              onPositionItems.splice(i, 1);\n            }\n          }\n        }\n      };\n\n      this._processOnPosition = function () {\n        var i,\n            item,\n            j = onPositionItems.length;\n        if (!j || !s.playState || onPositionFired >= j) return false;\n\n        for (i = j - 1; i >= 0; i--) {\n          item = onPositionItems[i];\n\n          if (!item.fired && s.position >= item.position) {\n            item.fired = true;\n            onPositionFired++;\n            item.method.apply(item.scope, [item.position]); //  reset j -- onPositionItems.length can be changed in the item callback above... occasionally breaking the loop.\n\n            j = onPositionItems.length;\n          }\n        }\n\n        return true;\n      };\n\n      this._resetOnPosition = function (nPosition) {\n        // reset \"fired\" for items interested in this position\n        var i,\n            item,\n            j = onPositionItems.length;\n        if (!j) return false;\n\n        for (i = j - 1; i >= 0; i--) {\n          item = onPositionItems[i];\n\n          if (item.fired && nPosition <= item.position) {\n            item.fired = false;\n            onPositionFired--;\n          }\n        }\n\n        return true;\n      };\n      /**\r\n       * SMSound() private internals\r\n       * --------------------------------\r\n       */\n\n\n      applyFromTo = function () {\n        var instanceOptions = s._iO,\n            f = instanceOptions.from,\n            t = instanceOptions.to,\n            start,\n            end;\n\n        end = function () {\n          // end has been reached.\n          sm2._wD(s.id + ': \"To\" time of ' + t + ' reached.'); // detach listener\n\n\n          s.clearOnPosition(t, end); // stop should clear this, too\n\n          s.stop();\n        };\n\n        start = function () {\n          sm2._wD(s.id + ': Playing \"from\" ' + f); // add listener for end\n\n\n          if (t !== null && !isNaN(t)) {\n            s.onPosition(t, end);\n          }\n        };\n\n        if (f !== null && !isNaN(f)) {\n          // apply to instance options, guaranteeing correct start position.\n          instanceOptions.position = f; // multiShot timing can't be tracked, so prevent that.\n\n          instanceOptions.multiShot = false;\n          start();\n        } // return updated instanceOptions including starting position\n\n\n        return instanceOptions;\n      };\n\n      attachOnPosition = function () {\n        var item,\n            op = s._iO.onposition; // attach onposition things, if any, now.\n\n        if (op) {\n          for (item in op) {\n            if (op.hasOwnProperty(item)) {\n              s.onPosition(parseInt(item, 10), op[item]);\n            }\n          }\n        }\n      };\n\n      detachOnPosition = function () {\n        var item,\n            op = s._iO.onposition; // detach any onposition()-style listeners.\n\n        if (op) {\n          for (item in op) {\n            if (op.hasOwnProperty(item)) {\n              s.clearOnPosition(parseInt(item, 10));\n            }\n          }\n        }\n      };\n\n      start_html5_timer = function () {\n        if (s.isHTML5) {\n          startTimer(s);\n        }\n      };\n\n      stop_html5_timer = function () {\n        if (s.isHTML5) {\n          stopTimer(s);\n        }\n      };\n\n      resetProperties = function (retainPosition) {\n        if (!retainPosition) {\n          onPositionItems = [];\n          onPositionFired = 0;\n        }\n\n        onplay_called = false;\n        s._hasTimer = null;\n        s._a = null;\n        s._html5_canplay = false;\n        s.bytesLoaded = null;\n        s.bytesTotal = null;\n        s.duration = s._iO && s._iO.duration ? s._iO.duration : null;\n        s.durationEstimate = null;\n        s.buffered = []; // legacy: 1D array\n\n        s.eqData = [];\n        s.eqData.left = [];\n        s.eqData.right = [];\n        s.failures = 0;\n        s.isBuffering = false;\n        s.instanceOptions = {};\n        s.instanceCount = 0;\n        s.loaded = false;\n        s.metadata = {}; // 0 = uninitialised, 1 = loading, 2 = failed/error, 3 = loaded/success\n\n        s.readyState = 0;\n        s.muted = false;\n        s.paused = false;\n        s.peakData = {\n          left: 0,\n          right: 0\n        };\n        s.waveformData = {\n          left: [],\n          right: []\n        };\n        s.playState = 0;\n        s.position = null;\n        s.id3 = {};\n      };\n\n      resetProperties();\n      /**\r\n       * Pseudo-private SMSound internals\r\n       * --------------------------------\r\n       */\n\n      this._onTimer = function (bForce) {\n        /**\r\n         * HTML5-only _whileplaying() etc.\r\n         * called from both HTML5 native events, and polling/interval-based timers\r\n         * mimics flash and fires only when time/duration change, so as to be polling-friendly\r\n         */\n        var duration,\n            isNew = false,\n            time,\n            x = {};\n\n        if (s._hasTimer || bForce) {\n          // TODO: May not need to track readyState (1 = loading)\n          if (s._a && (bForce || (s.playState > 0 || s.readyState === 1) && !s.paused)) {\n            duration = s._get_html5_duration();\n\n            if (duration !== lastHTML5State.duration) {\n              lastHTML5State.duration = duration;\n              s.duration = duration;\n              isNew = true;\n            } // TODO: investigate why this goes wack if not set/re-set each time.\n\n\n            s.durationEstimate = s.duration;\n            time = s._a.currentTime * msecScale || 0;\n\n            if (time !== lastHTML5State.time) {\n              lastHTML5State.time = time;\n              isNew = true;\n            }\n\n            if (isNew || bForce) {\n              s._whileplaying(time, x, x, x, x);\n            }\n          }\n          /* else {\r\n             // sm2._wD('_onTimer: Warn for \"'+s.id+'\": '+(!s._a?'Could not find element. ':'')+(s.playState === 0?'playState bad, 0?':'playState = '+s.playState+', OK'));\r\n             return false;\r\n           }*/\n\n        }\n\n        return isNew;\n      };\n\n      this._get_html5_duration = function () {\n        var instanceOptions = s._iO,\n            // if audio object exists, use its duration - else, instance option duration (if provided - it's a hack, really, and should be retired) OR null\n        d = s._a && s._a.duration ? s._a.duration * msecScale : instanceOptions && instanceOptions.duration ? instanceOptions.duration : null,\n            result = d && !isNaN(d) && d !== Infinity ? d : null;\n        return result;\n      };\n\n      this._apply_loop = function (a, nLoops) {\n        /**\r\n         * boolean instead of \"loop\", for webkit? - spec says string. http://www.w3.org/TR/html-markup/audio.html#audio.attrs.loop\r\n         * note that loop is either off or infinite under HTML5, unlike Flash which allows arbitrary loop counts to be specified.\r\n         */\n        // <d>\n        if (!a.loop && nLoops > 1) {\n          sm2._wD('Note: Native HTML5 looping is infinite.', 1);\n        } // </d>\n\n\n        a.loop = nLoops > 1 ? 'loop' : '';\n      };\n\n      this._setup_html5 = function (options) {\n        var instanceOptions = mixin(s._iO, options),\n            a = useGlobalHTML5Audio ? globalHTML5Audio : s._a,\n            dURL = decodeURI(instanceOptions.url),\n            sameURL;\n        /**\r\n         * \"First things first, I, Poppa...\" (reset the previous state of the old sound, if playing)\r\n         * Fixes case with devices that can only play one sound at a time\r\n         * Otherwise, other sounds in mid-play will be terminated without warning and in a stuck state\r\n         */\n\n        if (useGlobalHTML5Audio) {\n          if (dURL === decodeURI(lastGlobalHTML5URL)) {\n            // global HTML5 audio: re-use of URL\n            sameURL = true;\n          }\n        } else if (dURL === decodeURI(lastURL)) {\n          // options URL is the same as the \"last\" URL, and we used (loaded) it\n          sameURL = true;\n        }\n\n        if (a) {\n          if (a._s) {\n            if (useGlobalHTML5Audio) {\n              if (a._s && a._s.playState && !sameURL) {\n                // global HTML5 audio case, and loading a new URL. stop the currently-playing one.\n                a._s.stop();\n              }\n            } else if (!useGlobalHTML5Audio && dURL === decodeURI(lastURL)) {\n              // non-global HTML5 reuse case: same url, ignore request\n              s._apply_loop(a, instanceOptions.loops);\n\n              return a;\n            }\n          }\n\n          if (!sameURL) {\n            // don't retain onPosition() stuff with new URLs.\n            if (lastURL) {\n              resetProperties(false);\n            } // assign new HTML5 URL\n\n\n            a.src = instanceOptions.url;\n            s.url = instanceOptions.url;\n            lastURL = instanceOptions.url;\n            lastGlobalHTML5URL = instanceOptions.url;\n            a._called_load = false;\n          }\n        } else {\n          if (instanceOptions.autoLoad || instanceOptions.autoPlay) {\n            s._a = new Audio(instanceOptions.url);\n\n            s._a.load();\n          } else {\n            // null for stupid Opera 9.64 case\n            s._a = isOpera && opera.version() < 10 ? new Audio(null) : new Audio();\n          } // assign local reference\n\n\n          a = s._a;\n          a._called_load = false;\n\n          if (useGlobalHTML5Audio) {\n            globalHTML5Audio = a;\n          }\n        }\n\n        s.isHTML5 = true; // store a ref on the track\n\n        s._a = a; // store a ref on the audio\n\n        a._s = s;\n        add_html5_events();\n\n        s._apply_loop(a, instanceOptions.loops);\n\n        if (instanceOptions.autoLoad || instanceOptions.autoPlay) {\n          s.load();\n        } else {\n          // early HTML5 implementation (non-standard)\n          a.autobuffer = false; // standard ('none' is also an option.)\n\n          a.preload = 'auto';\n        }\n\n        return a;\n      };\n\n      add_html5_events = function () {\n        if (s._a._added_events) return false;\n        var f;\n\n        function add(oEvt, oFn, bCapture) {\n          return s._a ? s._a.addEventListener(oEvt, oFn, bCapture || false) : null;\n        }\n\n        s._a._added_events = true;\n\n        for (f in html5_events) {\n          if (html5_events.hasOwnProperty(f)) {\n            add(f, html5_events[f]);\n          }\n        }\n\n        return true;\n      };\n\n      remove_html5_events = function () {\n        // Remove event listeners\n        var f;\n\n        function remove(oEvt, oFn, bCapture) {\n          return s._a ? s._a.removeEventListener(oEvt, oFn, bCapture || false) : null;\n        }\n\n        sm2._wD(s.id + ': Removing event listeners');\n\n        s._a._added_events = false;\n\n        for (f in html5_events) {\n          if (html5_events.hasOwnProperty(f)) {\n            remove(f, html5_events[f]);\n          }\n        }\n      };\n      /**\r\n       * Pseudo-private event internals\r\n       * ------------------------------\r\n       */\n\n\n      this._onload = function (nSuccess) {\n        var fN,\n            // check for duration to prevent false positives from flash 8 when loading from cache.\n        loadOK = !!nSuccess || !s.isHTML5 && fV === 8 && s.duration; // <d>\n\n        fN = s.id + ': ';\n\n        sm2._wD(fN + (loadOK ? 'onload()' : 'Failed to load / invalid sound?' + (!s.duration ? ' Zero-length duration reported.' : ' -') + ' (' + s.url + ')'), loadOK ? 1 : 2);\n\n        if (!loadOK && !s.isHTML5) {\n          if (sm2.sandbox.noRemote === true) {\n            sm2._wD(fN + str('noNet'), 1);\n          }\n\n          if (sm2.sandbox.noLocal === true) {\n            sm2._wD(fN + str('noLocal'), 1);\n          }\n        } // </d>\n\n\n        s.loaded = loadOK;\n        s.readyState = loadOK ? 3 : 2;\n\n        s._onbufferchange(0);\n\n        if (!loadOK && !s.isHTML5) {\n          // note: no error code from Flash.\n          s._onerror();\n        }\n\n        if (s._iO.onload) {\n          wrapCallback(s, function () {\n            s._iO.onload.apply(s, [loadOK]);\n          });\n        }\n\n        return true;\n      };\n\n      this._onerror = function (errorCode, description) {\n        // https://html.spec.whatwg.org/multipage/embedded-content.html#error-codes\n        if (s._iO.onerror) {\n          wrapCallback(s, function () {\n            s._iO.onerror.apply(s, [errorCode, description]);\n          });\n        }\n      };\n\n      this._onbufferchange = function (nIsBuffering) {\n        // ignore if not playing\n        if (s.playState === 0) return false;\n        if (nIsBuffering && s.isBuffering || !nIsBuffering && !s.isBuffering) return false;\n        s.isBuffering = nIsBuffering === 1;\n\n        if (s._iO.onbufferchange) {\n          sm2._wD(s.id + ': Buffer state change: ' + nIsBuffering);\n\n          s._iO.onbufferchange.apply(s, [nIsBuffering]);\n        }\n\n        return true;\n      };\n      /**\r\n       * Playback may have stopped due to buffering, or related reason.\r\n       * This state can be encountered on iOS < 6 when auto-play is blocked.\r\n       */\n\n\n      this._onsuspend = function () {\n        if (s._iO.onsuspend) {\n          sm2._wD(s.id + ': Playback suspended');\n\n          s._iO.onsuspend.apply(s);\n        }\n\n        return true;\n      };\n      /**\r\n       * flash 9/movieStar + RTMP-only method, should fire only once at most\r\n       * at this point we just recreate failed sounds rather than trying to reconnect\r\n       */\n\n\n      this._onfailure = function (msg, level, code) {\n        s.failures++;\n\n        sm2._wD(s.id + ': Failure (' + s.failures + '): ' + msg);\n\n        if (s._iO.onfailure && s.failures === 1) {\n          s._iO.onfailure(msg, level, code);\n        } else {\n          sm2._wD(s.id + ': Ignoring failure');\n        }\n      };\n      /**\r\n       * flash 9/movieStar + RTMP-only method for unhandled warnings/exceptions from Flash\r\n       * e.g., RTMP \"method missing\" warning (non-fatal) for getStreamLength on server\r\n       */\n\n\n      this._onwarning = function (msg, level, code) {\n        if (s._iO.onwarning) {\n          s._iO.onwarning(msg, level, code);\n        }\n      };\n\n      this._onfinish = function () {\n        // store local copy before it gets trashed...\n        var io_onfinish = s._iO.onfinish;\n\n        s._onbufferchange(0);\n\n        s._resetOnPosition(0); // reset some state items\n\n\n        if (s.instanceCount) {\n          s.instanceCount--;\n\n          if (!s.instanceCount) {\n            // remove onPosition listeners, if any\n            detachOnPosition(); // reset instance options\n\n            s.playState = 0;\n            s.paused = false;\n            s.instanceCount = 0;\n            s.instanceOptions = {};\n            s._iO = {};\n            stop_html5_timer(); // reset position, too\n\n            if (s.isHTML5) {\n              s.position = 0;\n            }\n          }\n\n          if (!s.instanceCount || s._iO.multiShotEvents) {\n            // fire onfinish for last, or every instance\n            if (io_onfinish) {\n              sm2._wD(s.id + ': onfinish()');\n\n              wrapCallback(s, function () {\n                io_onfinish.apply(s);\n              });\n            }\n          }\n        }\n      };\n\n      this._whileloading = function (nBytesLoaded, nBytesTotal, nDuration, nBufferLength) {\n        var instanceOptions = s._iO;\n        s.bytesLoaded = nBytesLoaded;\n        s.bytesTotal = nBytesTotal;\n        s.duration = Math.floor(nDuration);\n        s.bufferLength = nBufferLength;\n\n        if (!s.isHTML5 && !instanceOptions.isMovieStar) {\n          if (instanceOptions.duration) {\n            // use duration from options, if specified and larger. nobody should be specifying duration in options, actually, and it should be retired.\n            s.durationEstimate = s.duration > instanceOptions.duration ? s.duration : instanceOptions.duration;\n          } else {\n            s.durationEstimate = parseInt(s.bytesTotal / s.bytesLoaded * s.duration, 10);\n          }\n        } else {\n          s.durationEstimate = s.duration;\n        } // for flash, reflect sequential-load-style buffering\n\n\n        if (!s.isHTML5) {\n          s.buffered = [{\n            start: 0,\n            end: s.duration\n          }];\n        } // allow whileloading to fire even if \"load\" fired under HTML5, due to HTTP range/partials\n\n\n        if ((s.readyState !== 3 || s.isHTML5) && instanceOptions.whileloading) {\n          instanceOptions.whileloading.apply(s);\n        }\n      };\n\n      this._whileplaying = function (nPosition, oPeakData, oWaveformDataLeft, oWaveformDataRight, oEQData) {\n        var instanceOptions = s._iO,\n            eqLeft; // flash safety net\n\n        if (isNaN(nPosition) || nPosition === null) return false; // Safari HTML5 play() may return small -ve values when starting from position: 0, eg. -50.120396875. Unexpected/invalid per W3, I think. Normalize to 0.\n\n        s.position = Math.max(0, nPosition);\n\n        s._processOnPosition();\n\n        if (!s.isHTML5 && fV > 8) {\n          if (instanceOptions.usePeakData && oPeakData !== _undefined && oPeakData) {\n            s.peakData = {\n              left: oPeakData.leftPeak,\n              right: oPeakData.rightPeak\n            };\n          }\n\n          if (instanceOptions.useWaveformData && oWaveformDataLeft !== _undefined && oWaveformDataLeft) {\n            s.waveformData = {\n              left: oWaveformDataLeft.split(','),\n              right: oWaveformDataRight.split(',')\n            };\n          }\n\n          if (instanceOptions.useEQData) {\n            if (oEQData !== _undefined && oEQData && oEQData.leftEQ) {\n              eqLeft = oEQData.leftEQ.split(',');\n              s.eqData = eqLeft;\n              s.eqData.left = eqLeft;\n\n              if (oEQData.rightEQ !== _undefined && oEQData.rightEQ) {\n                s.eqData.right = oEQData.rightEQ.split(',');\n              }\n            }\n          }\n        }\n\n        if (s.playState === 1) {\n          // special case/hack: ensure buffering is false if loading from cache (and not yet started)\n          if (!s.isHTML5 && fV === 8 && !s.position && s.isBuffering) {\n            s._onbufferchange(0);\n          }\n\n          if (instanceOptions.whileplaying) {\n            // flash may call after actual finish\n            instanceOptions.whileplaying.apply(s);\n          }\n        }\n\n        return true;\n      };\n\n      this._oncaptiondata = function (oData) {\n        /**\r\n         * internal: flash 9 + NetStream (MovieStar/RTMP-only) feature\r\n         *\r\n         * @param {object} oData\r\n         */\n        sm2._wD(s.id + ': Caption data received.');\n\n        s.captiondata = oData;\n\n        if (s._iO.oncaptiondata) {\n          s._iO.oncaptiondata.apply(s, [oData]);\n        }\n      };\n\n      this._onmetadata = function (oMDProps, oMDData) {\n        /**\r\n         * internal: flash 9 + NetStream (MovieStar/RTMP-only) feature\r\n         * RTMP may include song title, MovieStar content may include encoding info\r\n         *\r\n         * @param {array} oMDProps (names)\r\n         * @param {array} oMDData (values)\r\n         */\n        sm2._wD(s.id + ': Metadata received.');\n\n        var oData = {},\n            i,\n            j;\n\n        for (i = 0, j = oMDProps.length; i < j; i++) {\n          oData[oMDProps[i]] = oMDData[i];\n        }\n\n        s.metadata = oData;\n\n        if (s._iO.onmetadata) {\n          s._iO.onmetadata.call(s, s.metadata);\n        }\n      };\n\n      this._onid3 = function (oID3Props, oID3Data) {\n        /**\r\n         * internal: flash 8 + flash 9 ID3 feature\r\n         * may include artist, song title etc.\r\n         *\r\n         * @param {array} oID3Props (names)\r\n         * @param {array} oID3Data (values)\r\n         */\n        sm2._wD(s.id + ': ID3 data received.');\n\n        var oData = [],\n            i,\n            j;\n\n        for (i = 0, j = oID3Props.length; i < j; i++) {\n          oData[oID3Props[i]] = oID3Data[i];\n        }\n\n        s.id3 = mixin(s.id3, oData);\n\n        if (s._iO.onid3) {\n          s._iO.onid3.apply(s);\n        }\n      }; // flash/RTMP-only\n\n\n      this._onconnect = function (bSuccess) {\n        bSuccess = bSuccess === 1;\n\n        sm2._wD(s.id + ': ' + (bSuccess ? 'Connected.' : 'Failed to connect? - ' + s.url), bSuccess ? 1 : 2);\n\n        s.connected = bSuccess;\n\n        if (bSuccess) {\n          s.failures = 0;\n\n          if (idCheck(s.id)) {\n            if (s.getAutoPlay()) {\n              // only update the play state if auto playing\n              s.play(_undefined, s.getAutoPlay());\n            } else if (s._iO.autoLoad) {\n              s.load();\n            }\n          }\n\n          if (s._iO.onconnect) {\n            s._iO.onconnect.apply(s, [bSuccess]);\n          }\n        }\n      };\n\n      this._ondataerror = function (sError) {\n        // flash 9 wave/eq data handler\n        // hack: called at start, and end from flash at/after onfinish()\n        if (s.playState > 0) {\n          sm2._wD(s.id + ': Data error: ' + sError);\n\n          if (s._iO.ondataerror) {\n            s._iO.ondataerror.apply(s);\n          }\n        }\n      }; // <d>\n\n\n      this._debug(); // </d>\n\n    }; // SMSound()\n\n    /**\r\n     * Private SoundManager internals\r\n     * ------------------------------\r\n     */\n\n\n    getDocument = function () {\n      return doc.body || doc.getElementsByTagName('div')[0];\n    };\n\n    id = function (sID) {\n      return doc.getElementById(sID);\n    };\n\n    mixin = function (oMain, oAdd) {\n      // non-destructive merge\n      var o1 = oMain || {},\n          o2,\n          o; // if unspecified, o2 is the default options object\n\n      o2 = oAdd === _undefined ? sm2.defaultOptions : oAdd;\n\n      for (o in o2) {\n        if (o2.hasOwnProperty(o) && o1[o] === _undefined) {\n          if (typeof o2[o] !== 'object' || o2[o] === null) {\n            // assign directly\n            o1[o] = o2[o];\n          } else {\n            // recurse through o2\n            o1[o] = mixin(o1[o], o2[o]);\n          }\n        }\n      }\n\n      return o1;\n    };\n\n    wrapCallback = function (oSound, callback) {\n      /**\r\n       * 03/03/2013: Fix for Flash Player 11.6.602.171 + Flash 8 (flashVersion = 8) SWF issue\r\n       * setTimeout() fix for certain SMSound callbacks like onload() and onfinish(), where subsequent calls like play() and load() fail when Flash Player 11.6.602.171 is installed, and using soundManager with flashVersion = 8 (which is the default).\r\n       * Not sure of exact cause. Suspect race condition and/or invalid (NaN-style) position argument trickling down to the next JS -> Flash _start() call, in the play() case.\r\n       * Fix: setTimeout() to yield, plus safer null / NaN checking on position argument provided to Flash.\r\n       * https://getsatisfaction.com/schillmania/topics/recent_chrome_update_seems_to_have_broken_my_sm2_audio_player\r\n       */\n      if (!oSound.isHTML5 && fV === 8) {\n        window.setTimeout(callback, 0);\n      } else {\n        callback();\n      }\n    }; // additional soundManager properties that soundManager.setup() will accept\n\n\n    extraOptions = {\n      onready: 1,\n      ontimeout: 1,\n      defaultOptions: 1,\n      flash9Options: 1,\n      movieStarOptions: 1\n    };\n\n    assign = function (o, oParent) {\n      /**\r\n       * recursive assignment of properties, soundManager.setup() helper\r\n       * allows property assignment based on whitelist\r\n       */\n      var i,\n          result = true,\n          hasParent = oParent !== _undefined,\n          setupOptions = sm2.setupOptions,\n          bonusOptions = extraOptions; // <d>\n      // if soundManager.setup() called, show accepted parameters.\n\n      if (o === _undefined) {\n        result = [];\n\n        for (i in setupOptions) {\n          if (setupOptions.hasOwnProperty(i)) {\n            result.push(i);\n          }\n        }\n\n        for (i in bonusOptions) {\n          if (bonusOptions.hasOwnProperty(i)) {\n            if (typeof sm2[i] === 'object') {\n              result.push(i + ': {...}');\n            } else if (sm2[i] instanceof Function) {\n              result.push(i + ': function() {...}');\n            } else {\n              result.push(i);\n            }\n          }\n        }\n\n        sm2._wD(str('setup', result.join(', ')));\n\n        return false;\n      } // </d>\n\n\n      for (i in o) {\n        if (o.hasOwnProperty(i)) {\n          // if not an {object} we want to recurse through...\n          if (typeof o[i] !== 'object' || o[i] === null || o[i] instanceof Array || o[i] instanceof RegExp) {\n            // check \"allowed\" options\n            if (hasParent && bonusOptions[oParent] !== _undefined) {\n              // valid recursive / nested object option, eg., { defaultOptions: { volume: 50 } }\n              sm2[oParent][i] = o[i];\n            } else if (setupOptions[i] !== _undefined) {\n              // special case: assign to setupOptions object, which soundManager property references\n              sm2.setupOptions[i] = o[i]; // assign directly to soundManager, too\n\n              sm2[i] = o[i];\n            } else if (bonusOptions[i] === _undefined) {\n              // invalid or disallowed parameter. complain.\n              complain(str(sm2[i] === _undefined ? 'setupUndef' : 'setupError', i), 2);\n              result = false;\n            } else if (sm2[i] instanceof Function) {\n              /**\r\n               * valid extraOptions (bonusOptions) parameter.\r\n               * is it a method, like onready/ontimeout? call it.\r\n               * multiple parameters should be in an array, eg. soundManager.setup({onready: [myHandler, myScope]});\r\n               */\n              sm2[i].apply(sm2, o[i] instanceof Array ? o[i] : [o[i]]);\n            } else {\n              // good old-fashioned direct assignment\n              sm2[i] = o[i];\n            }\n          } else if (bonusOptions[i] === _undefined) {\n            // recursion case, eg., { defaultOptions: { ... } }\n            // invalid or disallowed parameter. complain.\n            complain(str(sm2[i] === _undefined ? 'setupUndef' : 'setupError', i), 2);\n            result = false;\n          } else {\n            // recurse through object\n            return assign(o[i], i);\n          }\n        }\n      }\n\n      return result;\n    };\n\n    function preferFlashCheck(kind) {\n      // whether flash should play a given type\n      return sm2.preferFlash && hasFlash && !sm2.ignoreFlash && sm2.flash[kind] !== _undefined && sm2.flash[kind];\n    }\n    /**\r\n     * Internal DOM2-level event helpers\r\n     * ---------------------------------\r\n     */\n\n\n    event = function () {\n      // normalize event methods\n      var old = window.attachEvent,\n          evt = {\n        add: old ? 'attachEvent' : 'addEventListener',\n        remove: old ? 'detachEvent' : 'removeEventListener'\n      }; // normalize \"on\" event prefix, optional capture argument\n\n      function getArgs(oArgs) {\n        var args = slice.call(oArgs),\n            len = args.length;\n\n        if (old) {\n          // prefix\n          args[1] = 'on' + args[1];\n\n          if (len > 3) {\n            // no capture\n            args.pop();\n          }\n        } else if (len === 3) {\n          args.push(false);\n        }\n\n        return args;\n      }\n\n      function apply(args, sType) {\n        // normalize and call the event method, with the proper arguments\n        var element = args.shift(),\n            method = [evt[sType]];\n\n        if (old) {\n          // old IE can't do apply().\n          element[method](args[0], args[1]);\n        } else {\n          element[method].apply(element, args);\n        }\n      }\n\n      function add() {\n        apply(getArgs(arguments), 'add');\n      }\n\n      function remove() {\n        apply(getArgs(arguments), 'remove');\n      }\n\n      return {\n        add: add,\n        remove: remove\n      };\n    }();\n    /**\r\n     * Internal HTML5 event handling\r\n     * -----------------------------\r\n     */\n\n\n    function html5_event(oFn) {\n      // wrap html5 event handlers so we don't call them on destroyed and/or unloaded sounds\n      return function (e) {\n        var s = this._s,\n            result;\n\n        if (!s || !s._a) {\n          // <d>\n          if (s && s.id) {\n            sm2._wD(s.id + ': Ignoring ' + e.type);\n          } else {\n            sm2._wD(h5 + 'Ignoring ' + e.type);\n          } // </d>\n\n\n          result = null;\n        } else {\n          result = oFn.call(this, e);\n        }\n\n        return result;\n      };\n    }\n\n    html5_events = {\n      // HTML5 event-name-to-handler map\n      abort: html5_event(function () {\n        sm2._wD(this._s.id + ': abort');\n      }),\n      // enough has loaded to play\n      canplay: html5_event(function () {\n        var s = this._s,\n            position1K;\n\n        if (s._html5_canplay) {\n          // this event has already fired. ignore.\n          return;\n        }\n\n        s._html5_canplay = true;\n\n        sm2._wD(s.id + ': canplay');\n\n        s._onbufferchange(0); // position according to instance options\n\n\n        position1K = s._iO.position !== _undefined && !isNaN(s._iO.position) ? s._iO.position / msecScale : null; // set the position if position was provided before the sound loaded\n\n        if (this.currentTime !== position1K) {\n          sm2._wD(s.id + ': canplay: Setting position to ' + position1K);\n\n          try {\n            this.currentTime = position1K;\n          } catch (ee) {\n            sm2._wD(s.id + ': canplay: Setting position of ' + position1K + ' failed: ' + ee.message, 2);\n          }\n        } // hack for HTML5 from/to case\n\n\n        if (s._iO._oncanplay) {\n          s._iO._oncanplay();\n        }\n      }),\n      canplaythrough: html5_event(function () {\n        var s = this._s;\n\n        if (!s.loaded) {\n          s._onbufferchange(0);\n\n          s._whileloading(s.bytesLoaded, s.bytesTotal, s._get_html5_duration());\n\n          s._onload(true);\n        }\n      }),\n      durationchange: html5_event(function () {\n        // durationchange may fire at various times, probably the safest way to capture accurate/final duration.\n        var s = this._s,\n            duration;\n        duration = s._get_html5_duration();\n\n        if (!isNaN(duration) && duration !== s.duration) {\n          sm2._wD(this._s.id + ': durationchange (' + duration + ')' + (s.duration ? ', previously ' + s.duration : ''));\n\n          s.durationEstimate = s.duration = duration;\n        }\n      }),\n      // TODO: Reserved for potential use\n\n      /*\r\n      emptied: html5_event(function() {\r\n          sm2._wD(this._s.id + ': emptied');\r\n        }),\r\n      */\n      ended: html5_event(function () {\n        var s = this._s;\n\n        sm2._wD(s.id + ': ended');\n\n        s._onfinish();\n      }),\n      error: html5_event(function () {\n        var description = html5ErrorCodes[this.error.code] || null;\n\n        sm2._wD(this._s.id + ': HTML5 error, code ' + this.error.code + (description ? ' (' + description + ')' : ''));\n\n        this._s._onload(false);\n\n        this._s._onerror(this.error.code, description);\n      }),\n      loadeddata: html5_event(function () {\n        var s = this._s;\n\n        sm2._wD(s.id + ': loadeddata'); // safari seems to nicely report progress events, eventually totalling 100%\n\n\n        if (!s._loaded && !isSafari) {\n          s.duration = s._get_html5_duration();\n        }\n      }),\n      loadedmetadata: html5_event(function () {\n        sm2._wD(this._s.id + ': loadedmetadata');\n      }),\n      loadstart: html5_event(function () {\n        sm2._wD(this._s.id + ': loadstart'); // assume buffering at first\n\n\n        this._s._onbufferchange(1);\n      }),\n      play: html5_event(function () {\n        // sm2._wD(this._s.id + ': play()');\n        // once play starts, no buffering\n        this._s._onbufferchange(0);\n      }),\n      playing: html5_event(function () {\n        sm2._wD(this._s.id + ': playing ' + String.fromCharCode(9835)); // once play starts, no buffering\n\n\n        this._s._onbufferchange(0);\n      }),\n      progress: html5_event(function (e) {\n        // note: can fire repeatedly after \"loaded\" event, due to use of HTTP range/partials\n        var s = this._s,\n            i,\n            j,\n            progStr,\n            buffered = 0,\n            isProgress = e.type === 'progress',\n            ranges = e.target.buffered,\n            // firefox 3.6 implements e.loaded/total (bytes)\n        loaded = e.loaded || 0,\n            total = e.total || 1; // reset the \"buffered\" (loaded byte ranges) array\n\n        s.buffered = [];\n\n        if (ranges && ranges.length) {\n          // if loaded is 0, try TimeRanges implementation as % of load\n          // https://developer.mozilla.org/en/DOM/TimeRanges\n          // re-build \"buffered\" array\n          // HTML5 returns seconds. SM2 API uses msec for setPosition() etc., whether Flash or HTML5.\n          for (i = 0, j = ranges.length; i < j; i++) {\n            s.buffered.push({\n              start: ranges.start(i) * msecScale,\n              end: ranges.end(i) * msecScale\n            });\n          } // use the last value locally\n\n\n          buffered = (ranges.end(0) - ranges.start(0)) * msecScale; // linear case, buffer sum; does not account for seeking and HTTP partials / byte ranges\n\n          loaded = Math.min(1, buffered / (e.target.duration * msecScale)); // <d>\n\n          if (isProgress && ranges.length > 1) {\n            progStr = [];\n            j = ranges.length;\n\n            for (i = 0; i < j; i++) {\n              progStr.push(e.target.buffered.start(i) * msecScale + '-' + e.target.buffered.end(i) * msecScale);\n            }\n\n            sm2._wD(this._s.id + ': progress, timeRanges: ' + progStr.join(', '));\n          }\n\n          if (isProgress && !isNaN(loaded)) {\n            sm2._wD(this._s.id + ': progress, ' + Math.floor(loaded * 100) + '% loaded');\n          } // </d>\n\n        }\n\n        if (!isNaN(loaded)) {\n          // TODO: prevent calls with duplicate values.\n          s._whileloading(loaded, total, s._get_html5_duration());\n\n          if (loaded && total && loaded === total) {\n            // in case \"onload\" doesn't fire (eg. gecko 1.9.2)\n            html5_events.canplaythrough.call(this, e);\n          }\n        }\n      }),\n      ratechange: html5_event(function () {\n        sm2._wD(this._s.id + ': ratechange');\n      }),\n      suspend: html5_event(function (e) {\n        // download paused/stopped, may have finished (eg. onload)\n        var s = this._s;\n\n        sm2._wD(this._s.id + ': suspend');\n\n        html5_events.progress.call(this, e);\n\n        s._onsuspend();\n      }),\n      stalled: html5_event(function () {\n        sm2._wD(this._s.id + ': stalled');\n      }),\n      timeupdate: html5_event(function () {\n        this._s._onTimer();\n      }),\n      waiting: html5_event(function () {\n        var s = this._s; // see also: seeking\n\n        sm2._wD(this._s.id + ': waiting'); // playback faster than download rate, etc.\n\n\n        s._onbufferchange(1);\n      })\n    };\n\n    html5OK = function (iO) {\n      // playability test based on URL or MIME type\n      var result;\n\n      if (!iO || !iO.type && !iO.url && !iO.serverURL) {\n        // nothing to check\n        result = false;\n      } else if (iO.serverURL || iO.type && preferFlashCheck(iO.type)) {\n        // RTMP, or preferring flash\n        result = false;\n      } else {\n        // Use type, if specified. Pass data: URIs to HTML5. If HTML5-only mode, no other options, so just give 'er\n        result = iO.type ? html5CanPlay({\n          type: iO.type\n        }) : html5CanPlay({\n          url: iO.url\n        }) || sm2.html5Only || iO.url.match(/data:/i);\n      }\n\n      return result;\n    };\n\n    html5Unload = function (oAudio) {\n      /**\r\n       * Internal method: Unload media, and cancel any current/pending network requests.\r\n       * Firefox can load an empty URL, which allegedly destroys the decoder and stops the download.\r\n       * https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox#Stopping_the_download_of_media\r\n       * However, Firefox has been seen loading a relative URL from '' and thus requesting the hosting page on unload.\r\n       * Other UA behaviour is unclear, so everyone else gets an about:blank-style URL.\r\n       */\n      var url;\n\n      if (oAudio) {\n        // Firefox and Chrome accept short WAVe data: URIs. Chome dislikes audio/wav, but accepts audio/wav for data: MIME.\n        // Desktop Safari complains / fails on data: URI, so it gets about:blank.\n        url = isSafari ? emptyURL : sm2.html5.canPlayType('audio/wav') ? emptyWAV : emptyURL;\n        oAudio.src = url; // reset some state, too\n\n        if (oAudio._called_unload !== _undefined) {\n          oAudio._called_load = false;\n        }\n      }\n\n      if (useGlobalHTML5Audio) {\n        // ensure URL state is trashed, also\n        lastGlobalHTML5URL = null;\n      }\n\n      return url;\n    };\n\n    html5CanPlay = function (o) {\n      /**\r\n       * Try to find MIME, test and return truthiness\r\n       * o = {\r\n       *  url: '/path/to/an.mp3',\r\n       *  type: 'audio/mp3'\r\n       * }\r\n       */\n      if (!sm2.useHTML5Audio || !sm2.hasHTML5) return false;\n      var url = o.url || null,\n          mime = o.type || null,\n          aF = sm2.audioFormats,\n          result,\n          offset,\n          fileExt,\n          item; // account for known cases like audio/mp3\n\n      if (mime && sm2.html5[mime] !== _undefined) return sm2.html5[mime] && !preferFlashCheck(mime);\n\n      if (!html5Ext) {\n        html5Ext = [];\n\n        for (item in aF) {\n          if (aF.hasOwnProperty(item)) {\n            html5Ext.push(item);\n\n            if (aF[item].related) {\n              html5Ext = html5Ext.concat(aF[item].related);\n            }\n          }\n        }\n\n        html5Ext = new RegExp('\\\\.(' + html5Ext.join('|') + ')(\\\\?.*)?$', 'i');\n      } // TODO: Strip URL queries, etc.\n\n\n      fileExt = url ? url.toLowerCase().match(html5Ext) : null;\n\n      if (!fileExt || !fileExt.length) {\n        if (!mime) {\n          result = false;\n        } else {\n          // audio/mp3 -> mp3, result should be known\n          offset = mime.indexOf(';'); // strip \"audio/X; codecs...\"\n\n          fileExt = (offset !== -1 ? mime.substr(0, offset) : mime).substr(6);\n        }\n      } else {\n        // match the raw extension name - \"mp3\", for example\n        fileExt = fileExt[1];\n      }\n\n      if (fileExt && sm2.html5[fileExt] !== _undefined) {\n        // result known\n        result = sm2.html5[fileExt] && !preferFlashCheck(fileExt);\n      } else {\n        mime = 'audio/' + fileExt;\n        result = sm2.html5.canPlayType({\n          type: mime\n        });\n        sm2.html5[fileExt] = result; // sm2._wD('canPlayType, found result: ' + result);\n\n        result = result && sm2.html5[mime] && !preferFlashCheck(mime);\n      }\n\n      return result;\n    };\n\n    testHTML5 = function () {\n      /**\r\n       * Internal: Iterates over audioFormats, determining support eg. audio/mp3, audio/mpeg and so on\r\n       * assigns results to html5[] and flash[].\r\n       */\n      if (!sm2.useHTML5Audio || !sm2.hasHTML5) {\n        // without HTML5, we need Flash.\n        sm2.html5.usingFlash = true;\n        needsFlash = true;\n        return false;\n      } // double-whammy: Opera 9.64 throws WRONG_ARGUMENTS_ERR if no parameter passed to Audio(), and Webkit + iOS happily tries to load \"null\" as a URL. :/\n\n\n      var a = Audio !== _undefined ? isOpera && opera.version() < 10 ? new Audio(null) : new Audio() : null,\n          item,\n          lookup,\n          support = {},\n          aF,\n          i;\n\n      function cp(m) {\n        var canPlay,\n            j,\n            result = false,\n            isOK = false;\n        if (!a || typeof a.canPlayType !== 'function') return result;\n\n        if (m instanceof Array) {\n          // iterate through all mime types, return any successes\n          for (i = 0, j = m.length; i < j; i++) {\n            if (sm2.html5[m[i]] || a.canPlayType(m[i]).match(sm2.html5Test)) {\n              isOK = true;\n              sm2.html5[m[i]] = true; // note flash support, too\n\n              sm2.flash[m[i]] = !!m[i].match(flashMIME);\n            }\n          }\n\n          result = isOK;\n        } else {\n          canPlay = a && typeof a.canPlayType === 'function' ? a.canPlayType(m) : false;\n          result = !!(canPlay && canPlay.match(sm2.html5Test));\n        }\n\n        return result;\n      } // test all registered formats + codecs\n\n\n      aF = sm2.audioFormats;\n\n      for (item in aF) {\n        if (aF.hasOwnProperty(item)) {\n          lookup = 'audio/' + item;\n          support[item] = cp(aF[item].type); // write back generic type too, eg. audio/mp3\n\n          support[lookup] = support[item]; // assign flash\n\n          if (item.match(flashMIME)) {\n            sm2.flash[item] = true;\n            sm2.flash[lookup] = true;\n          } else {\n            sm2.flash[item] = false;\n            sm2.flash[lookup] = false;\n          } // assign result to related formats, too\n\n\n          if (aF[item] && aF[item].related) {\n            for (i = aF[item].related.length - 1; i >= 0; i--) {\n              // eg. audio/m4a\n              support['audio/' + aF[item].related[i]] = support[item];\n              sm2.html5[aF[item].related[i]] = support[item];\n              sm2.flash[aF[item].related[i]] = support[item];\n            }\n          }\n        }\n      }\n\n      support.canPlayType = a ? cp : null;\n      sm2.html5 = mixin(sm2.html5, support);\n      sm2.html5.usingFlash = featureCheck();\n      needsFlash = sm2.html5.usingFlash;\n      return true;\n    };\n\n    strings = {\n      // <d>\n      notReady: 'Unavailable - wait until onready() has fired.',\n      notOK: 'Audio support is not available.',\n      domError: sm + 'exception caught while appending SWF to DOM.',\n      spcWmode: 'Removing wmode, preventing known SWF loading issue(s)',\n      swf404: smc + 'Verify that %s is a valid path.',\n      tryDebug: 'Try ' + sm + '.debugFlash = true for more security details (output goes to SWF.)',\n      checkSWF: 'See SWF output for more debug info.',\n      localFail: smc + 'Non-HTTP page (' + doc.location.protocol + ' URL?) Review Flash player security settings for this special case:\\nhttp://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html\\nMay need to add/allow path, eg. c:/sm2/ or /users/me/sm2/',\n      waitFocus: smc + 'Special case: Waiting for SWF to load with window focus...',\n      waitForever: smc + 'Waiting indefinitely for Flash (will recover if unblocked)...',\n      waitSWF: smc + 'Waiting for 100% SWF load...',\n      needFunction: smc + 'Function object expected for %s',\n      badID: 'Sound ID \"%s\" should be a string, starting with a non-numeric character',\n      currentObj: smc + '_debug(): Current sound objects',\n      waitOnload: smc + 'Waiting for window.onload()',\n      docLoaded: smc + 'Document already loaded',\n      onload: smc + 'initComplete(): calling soundManager.onload()',\n      onloadOK: sm + '.onload() complete',\n      didInit: smc + 'init(): Already called?',\n      secNote: 'Flash security note: Network/internet URLs will not load due to security restrictions. Access can be configured via Flash Player Global Security Settings Page: http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html',\n      badRemove: smc + 'Failed to remove Flash node.',\n      shutdown: sm + '.disable(): Shutting down',\n      queue: smc + 'Queueing %s handler',\n      smError: 'SMSound.load(): Exception: JS-Flash communication failed, or JS error.',\n      fbTimeout: 'No flash response, applying .' + swfCSS.swfTimedout + ' CSS...',\n      fbLoaded: 'Flash loaded',\n      fbHandler: smc + 'flashBlockHandler()',\n      manURL: 'SMSound.load(): Using manually-assigned URL',\n      onURL: sm + '.load(): current URL already assigned.',\n      badFV: sm + '.flashVersion must be 8 or 9. \"%s\" is invalid. Reverting to %s.',\n      as2loop: 'Note: Setting stream:false so looping can work (flash 8 limitation)',\n      noNSLoop: 'Note: Looping not implemented for MovieStar formats',\n      needfl9: 'Note: Switching to flash 9, required for MP4 formats.',\n      mfTimeout: 'Setting flashLoadTimeout = 0 (infinite) for off-screen, mobile flash case',\n      needFlash: smc + 'Fatal error: Flash is needed to play some required formats, but is not available.',\n      gotFocus: smc + 'Got window focus.',\n      policy: 'Enabling usePolicyFile for data access',\n      setup: sm + '.setup(): allowed parameters: %s',\n      setupError: sm + '.setup(): \"%s\" cannot be assigned with this method.',\n      setupUndef: sm + '.setup(): Could not find option \"%s\"',\n      setupLate: sm + '.setup(): url, flashVersion and html5Test property changes will not take effect until reboot().',\n      noURL: smc + 'Flash URL required. Call soundManager.setup({url:...}) to get started.',\n      sm2Loaded: 'SoundManager 2: Ready. ' + String.fromCharCode(10003),\n      reset: sm + '.reset(): Removing event callbacks',\n      mobileUA: 'Mobile UA detected, preferring HTML5 by default.',\n      globalHTML5: 'Using singleton HTML5 Audio() pattern for this device.',\n      ignoreMobile: 'Ignoring mobile restrictions for this device.' // </d>\n\n    };\n\n    str = function () {\n      // internal string replace helper.\n      // arguments: o [,items to replace]\n      // <d>\n      var args, i, j, o, sstr; // real array, please\n\n      args = slice.call(arguments); // first argument\n\n      o = args.shift();\n      sstr = strings && strings[o] ? strings[o] : '';\n\n      if (sstr && args && args.length) {\n        for (i = 0, j = args.length; i < j; i++) {\n          sstr = sstr.replace('%s', args[i]);\n        }\n      }\n\n      return sstr; // </d>\n    };\n\n    loopFix = function (sOpt) {\n      // flash 8 requires stream = false for looping to work\n      if (fV === 8 && sOpt.loops > 1 && sOpt.stream) {\n        _wDS('as2loop');\n\n        sOpt.stream = false;\n      }\n\n      return sOpt;\n    };\n\n    policyFix = function (sOpt, sPre) {\n      if (sOpt && !sOpt.usePolicyFile && (sOpt.onid3 || sOpt.usePeakData || sOpt.useWaveformData || sOpt.useEQData)) {\n        sm2._wD((sPre || '') + str('policy'));\n\n        sOpt.usePolicyFile = true;\n      }\n\n      return sOpt;\n    };\n\n    complain = function (sMsg) {\n      // <d>\n      if (hasConsole && console.warn !== _undefined) {\n        console.warn(sMsg);\n      } else {\n        sm2._wD(sMsg);\n      } // </d>\n\n    };\n\n    doNothing = function () {\n      return false;\n    };\n\n    disableObject = function (o) {\n      var oProp;\n\n      for (oProp in o) {\n        if (o.hasOwnProperty(oProp) && typeof o[oProp] === 'function') {\n          o[oProp] = doNothing;\n        }\n      }\n\n      oProp = null;\n    };\n\n    failSafely = function (bNoDisable) {\n      // general failure exception handler\n      if (bNoDisable === _undefined) {\n        bNoDisable = false;\n      }\n\n      if (disabled || bNoDisable) {\n        sm2.disable(bNoDisable);\n      }\n    };\n\n    normalizeMovieURL = function (movieURL) {\n      var urlParams = null,\n          url;\n\n      if (movieURL) {\n        if (movieURL.match(/\\.swf(\\?.*)?$/i)) {\n          urlParams = movieURL.substr(movieURL.toLowerCase().lastIndexOf('.swf?') + 4); // assume user knows what they're doing\n\n          if (urlParams) return movieURL;\n        } else if (movieURL.lastIndexOf('/') !== movieURL.length - 1) {\n          // append trailing slash, if needed\n          movieURL += '/';\n        }\n      }\n\n      url = (movieURL && movieURL.lastIndexOf('/') !== -1 ? movieURL.substr(0, movieURL.lastIndexOf('/') + 1) : './') + sm2.movieURL;\n\n      if (sm2.noSWFCache) {\n        url += '?ts=' + new Date().getTime();\n      }\n\n      return url;\n    };\n\n    setVersionInfo = function () {\n      // short-hand for internal use\n      fV = parseInt(sm2.flashVersion, 10);\n\n      if (fV !== 8 && fV !== 9) {\n        sm2._wD(str('badFV', fV, defaultFlashVersion));\n\n        sm2.flashVersion = fV = defaultFlashVersion;\n      } // debug flash movie, if applicable\n\n\n      var isDebug = sm2.debugMode || sm2.debugFlash ? '_debug.swf' : '.swf';\n\n      if (sm2.useHTML5Audio && !sm2.html5Only && sm2.audioFormats.mp4.required && fV < 9) {\n        sm2._wD(str('needfl9'));\n\n        sm2.flashVersion = fV = 9;\n      }\n\n      sm2.version = sm2.versionNumber + (sm2.html5Only ? ' (HTML5-only mode)' : fV === 9 ? ' (AS3/Flash 9)' : ' (AS2/Flash 8)'); // set up default options\n\n      if (fV > 8) {\n        // +flash 9 base options\n        sm2.defaultOptions = mixin(sm2.defaultOptions, sm2.flash9Options);\n        sm2.features.buffering = true; // +moviestar support\n\n        sm2.defaultOptions = mixin(sm2.defaultOptions, sm2.movieStarOptions);\n        sm2.filePatterns.flash9 = new RegExp('\\\\.(mp3|' + netStreamTypes.join('|') + ')(\\\\?.*)?$', 'i');\n        sm2.features.movieStar = true;\n      } else {\n        sm2.features.movieStar = false;\n      } // regExp for flash canPlay(), etc.\n\n\n      sm2.filePattern = sm2.filePatterns[fV !== 8 ? 'flash9' : 'flash8']; // if applicable, use _debug versions of SWFs\n\n      sm2.movieURL = (fV === 8 ? 'soundmanager2.swf' : 'soundmanager2_flash9.swf').replace('.swf', isDebug);\n      sm2.features.peakData = sm2.features.waveformData = sm2.features.eqData = fV > 8;\n    };\n\n    setPolling = function (bPolling, bHighPerformance) {\n      if (!flash) {\n        return;\n      }\n\n      flash._setPolling(bPolling, bHighPerformance);\n    };\n\n    initDebug = function () {\n      // starts debug mode, creating output <div> for UAs without console object\n      // allow force of debug mode via URL\n      // <d>\n      if (sm2.debugURLParam.test(wl)) {\n        sm2.setupOptions.debugMode = sm2.debugMode = true;\n      }\n\n      if (id(sm2.debugID)) {\n        return;\n      }\n\n      var oD, oDebug, oTarget, oToggle, tmp;\n\n      if (sm2.debugMode && !id(sm2.debugID) && (!hasConsole || !sm2.useConsole || !sm2.consoleOnly)) {\n        oD = doc.createElement('div');\n        oD.id = sm2.debugID + '-toggle';\n        oToggle = {\n          position: 'fixed',\n          bottom: '0px',\n          right: '0px',\n          width: '1.2em',\n          height: '1.2em',\n          lineHeight: '1.2em',\n          margin: '2px',\n          textAlign: 'center',\n          border: '1px solid #999',\n          cursor: 'pointer',\n          background: '#fff',\n          color: '#333',\n          zIndex: 10001\n        };\n        oD.appendChild(doc.createTextNode('-'));\n        oD.onclick = toggleDebug;\n        oD.title = 'Toggle SM2 debug console';\n\n        if (ua.match(/msie 6/i)) {\n          oD.style.position = 'absolute';\n          oD.style.cursor = 'hand';\n        }\n\n        for (tmp in oToggle) {\n          if (oToggle.hasOwnProperty(tmp)) {\n            oD.style[tmp] = oToggle[tmp];\n          }\n        }\n\n        oDebug = doc.createElement('div');\n        oDebug.id = sm2.debugID;\n        oDebug.style.display = sm2.debugMode ? 'block' : 'none';\n\n        if (sm2.debugMode && !id(oD.id)) {\n          try {\n            oTarget = getDocument();\n            oTarget.appendChild(oD);\n          } catch (e2) {\n            throw new Error(str('domError') + ' \\n' + e2.toString());\n          }\n\n          oTarget.appendChild(oDebug);\n        }\n      }\n\n      oTarget = null; // </d>\n    };\n\n    idCheck = this.getSoundById; // <d>\n\n    _wDS = function (o, errorLevel) {\n      return !o ? '' : sm2._wD(str(o), errorLevel);\n    };\n\n    toggleDebug = function () {\n      var o = id(sm2.debugID),\n          oT = id(sm2.debugID + '-toggle');\n\n      if (!o) {\n        return;\n      }\n\n      if (debugOpen) {\n        // minimize\n        oT.innerHTML = '+';\n        o.style.display = 'none';\n      } else {\n        oT.innerHTML = '-';\n        o.style.display = 'block';\n      }\n\n      debugOpen = !debugOpen;\n    };\n\n    debugTS = function (sEventType, bSuccess, sMessage) {\n      // troubleshooter debug hooks\n      if (window.sm2Debugger !== _undefined) {\n        try {\n          sm2Debugger.handleEvent(sEventType, bSuccess, sMessage);\n        } catch (e) {\n          // oh well\n          return false;\n        }\n      }\n\n      return true;\n    }; // </d>\n\n\n    getSWFCSS = function () {\n      var css = [];\n\n      if (sm2.debugMode) {\n        css.push(swfCSS.sm2Debug);\n      }\n\n      if (sm2.debugFlash) {\n        css.push(swfCSS.flashDebug);\n      }\n\n      if (sm2.useHighPerformance) {\n        css.push(swfCSS.highPerf);\n      }\n\n      return css.join(' ');\n    };\n\n    flashBlockHandler = function () {\n      // *possible* flash block situation.\n      var name = str('fbHandler'),\n          p = sm2.getMoviePercent(),\n          css = swfCSS,\n          error = {\n        type: 'FLASHBLOCK'\n      };\n\n      if (sm2.html5Only) {\n        // no flash, or unused\n        return;\n      }\n\n      if (!sm2.ok()) {\n        if (needsFlash) {\n          // make the movie more visible, so user can fix\n          sm2.oMC.className = getSWFCSS() + ' ' + css.swfDefault + ' ' + (p === null ? css.swfTimedout : css.swfError);\n\n          sm2._wD(name + ': ' + str('fbTimeout') + (p ? ' (' + str('fbLoaded') + ')' : ''));\n        }\n\n        sm2.didFlashBlock = true; // fire onready(), complain lightly\n\n        processOnEvents({\n          type: 'ontimeout',\n          ignoreInit: true,\n          error: error\n        });\n        catchError(error);\n      } else {\n        // SM2 loaded OK (or recovered)\n        // <d>\n        if (sm2.didFlashBlock) {\n          sm2._wD(name + ': Unblocked');\n        } // </d>\n\n\n        if (sm2.oMC) {\n          sm2.oMC.className = [getSWFCSS(), css.swfDefault, css.swfLoaded + (sm2.didFlashBlock ? ' ' + css.swfUnblocked : '')].join(' ');\n        }\n      }\n    };\n\n    addOnEvent = function (sType, oMethod, oScope) {\n      if (on_queue[sType] === _undefined) {\n        on_queue[sType] = [];\n      }\n\n      on_queue[sType].push({\n        method: oMethod,\n        scope: oScope || null,\n        fired: false\n      });\n    };\n\n    processOnEvents = function (oOptions) {\n      // if unspecified, assume OK/error\n      if (!oOptions) {\n        oOptions = {\n          type: sm2.ok() ? 'onready' : 'ontimeout'\n        };\n      } // not ready yet.\n\n\n      if (!didInit && oOptions && !oOptions.ignoreInit) return false; // invalid case\n\n      if (oOptions.type === 'ontimeout' && (sm2.ok() || disabled && !oOptions.ignoreInit)) return false;\n      var status = {\n        success: oOptions && oOptions.ignoreInit ? sm2.ok() : !disabled\n      },\n          // queue specified by type, or none\n      srcQueue = oOptions && oOptions.type ? on_queue[oOptions.type] || [] : [],\n          queue = [],\n          i,\n          j,\n          args = [status],\n          canRetry = needsFlash && !sm2.ok();\n\n      if (oOptions.error) {\n        args[0].error = oOptions.error;\n      }\n\n      for (i = 0, j = srcQueue.length; i < j; i++) {\n        if (srcQueue[i].fired !== true) {\n          queue.push(srcQueue[i]);\n        }\n      }\n\n      if (queue.length) {\n        // sm2._wD(sm + ': Firing ' + queue.length + ' ' + oOptions.type + '() item' + (queue.length === 1 ? '' : 's'));\n        for (i = 0, j = queue.length; i < j; i++) {\n          if (queue[i].scope) {\n            queue[i].method.apply(queue[i].scope, args);\n          } else {\n            queue[i].method.apply(this, args);\n          }\n\n          if (!canRetry) {\n            // useFlashBlock and SWF timeout case doesn't count here.\n            queue[i].fired = true;\n          }\n        }\n      }\n\n      return true;\n    };\n\n    initUserOnload = function () {\n      window.setTimeout(function () {\n        if (sm2.useFlashBlock) {\n          flashBlockHandler();\n        }\n\n        processOnEvents(); // call user-defined \"onload\", scoped to window\n\n        if (typeof sm2.onload === 'function') {\n          _wDS('onload', 1);\n\n          sm2.onload.apply(window);\n\n          _wDS('onloadOK', 1);\n        }\n\n        if (sm2.waitForWindowLoad) {\n          event.add(window, 'load', initUserOnload);\n        }\n      }, 1);\n    };\n\n    detectFlash = function () {\n      /**\r\n       * Hat tip: Flash Detect library (BSD, (C) 2007) by Carl \"DocYes\" S. Yestrau\r\n       * http://featureblend.com/javascript-flash-detection-library.html / http://featureblend.com/license.txt\r\n       */\n      // this work has already been done.\n      if (hasFlash !== _undefined) return hasFlash;\n      var hasPlugin = false,\n          n = navigator,\n          obj,\n          type,\n          types,\n          AX = window.ActiveXObject; // MS Edge 14 throws an \"Unspecified Error\" because n.plugins is inaccessible due to permissions\n\n      var nP;\n\n      try {\n        nP = n.plugins;\n      } catch (e) {\n        nP = undefined;\n      }\n\n      if (nP && nP.length) {\n        type = 'application/x-shockwave-flash';\n        types = n.mimeTypes;\n\n        if (types && types[type] && types[type].enabledPlugin && types[type].enabledPlugin.description) {\n          hasPlugin = true;\n        }\n      } else if (AX !== _undefined && !ua.match(/MSAppHost/i)) {\n        // Windows 8 Store Apps (MSAppHost) are weird (compatibility?) and won't complain here, but will barf if Flash/ActiveX object is appended to the DOM.\n        try {\n          obj = new AX('ShockwaveFlash.ShockwaveFlash');\n        } catch (e) {\n          // oh well\n          obj = null;\n        }\n\n        hasPlugin = !!obj; // cleanup, because it is ActiveX after all\n\n        obj = null;\n      }\n\n      hasFlash = hasPlugin;\n      return hasPlugin;\n    };\n\n    featureCheck = function () {\n      var flashNeeded,\n          item,\n          formats = sm2.audioFormats,\n          // iPhone <= 3.1 has broken HTML5 audio(), but firmware 3.2 (original iPad) + iOS4 works.\n      isSpecial = is_iDevice && !!ua.match(/os (1|2|3_0|3_1)\\s/i);\n\n      if (isSpecial) {\n        // has Audio(), but is broken; let it load links directly.\n        sm2.hasHTML5 = false; // ignore flash case, however\n\n        sm2.html5Only = true; // hide the SWF, if present\n\n        if (sm2.oMC) {\n          sm2.oMC.style.display = 'none';\n        }\n      } else if (sm2.useHTML5Audio) {\n        if (!sm2.html5 || !sm2.html5.canPlayType) {\n          sm2._wD('SoundManager: No HTML5 Audio() support detected.');\n\n          sm2.hasHTML5 = false;\n        } // <d>\n\n\n        if (isBadSafari) {\n          sm2._wD(smc + 'Note: Buggy HTML5 Audio in Safari on this OS X release, see https://bugs.webkit.org/show_bug.cgi?id=32159 - ' + (!hasFlash ? ' would use flash fallback for MP3/MP4, but none detected.' : 'will use flash fallback for MP3/MP4, if available'), 1);\n        } // </d>\n\n      }\n\n      if (sm2.useHTML5Audio && sm2.hasHTML5) {\n        // sort out whether flash is optional, required or can be ignored.\n        // innocent until proven guilty.\n        canIgnoreFlash = true;\n\n        for (item in formats) {\n          if (formats.hasOwnProperty(item)) {\n            if (formats[item].required) {\n              if (!sm2.html5.canPlayType(formats[item].type)) {\n                // 100% HTML5 mode is not possible.\n                canIgnoreFlash = false;\n                flashNeeded = true;\n              } else if (sm2.preferFlash && (sm2.flash[item] || sm2.flash[formats[item].type])) {\n                // flash may be required, or preferred for this format.\n                flashNeeded = true;\n              }\n            }\n          }\n        }\n      } // sanity check...\n\n\n      if (sm2.ignoreFlash) {\n        flashNeeded = false;\n        canIgnoreFlash = true;\n      }\n\n      sm2.html5Only = sm2.hasHTML5 && sm2.useHTML5Audio && !flashNeeded;\n      return !sm2.html5Only;\n    };\n\n    parseURL = function (url) {\n      /**\r\n       * Internal: Finds and returns the first playable URL (or failing that, the first URL.)\r\n       * @param {string or array} url A single URL string, OR, an array of URL strings or {url:'/path/to/resource', type:'audio/mp3'} objects.\r\n       */\n      var i,\n          j,\n          urlResult = 0,\n          result;\n\n      if (url instanceof Array) {\n        // find the first good one\n        for (i = 0, j = url.length; i < j; i++) {\n          if (url[i] instanceof Object) {\n            // MIME check\n            if (sm2.canPlayMIME(url[i].type)) {\n              urlResult = i;\n              break;\n            }\n          } else if (sm2.canPlayURL(url[i])) {\n            // URL string check\n            urlResult = i;\n            break;\n          }\n        } // normalize to string\n\n\n        if (url[urlResult].url) {\n          url[urlResult] = url[urlResult].url;\n        }\n\n        result = url[urlResult];\n      } else {\n        // single URL case\n        result = url;\n      }\n\n      return result;\n    };\n\n    startTimer = function (oSound) {\n      /**\r\n       * attach a timer to this sound, and start an interval if needed\r\n       */\n      if (!oSound._hasTimer) {\n        oSound._hasTimer = true;\n\n        if (!mobileHTML5 && sm2.html5PollingInterval) {\n          if (h5IntervalTimer === null && h5TimerCount === 0) {\n            h5IntervalTimer = setInterval(timerExecute, sm2.html5PollingInterval);\n          }\n\n          h5TimerCount++;\n        }\n      }\n    };\n\n    stopTimer = function (oSound) {\n      /**\r\n       * detach a timer\r\n       */\n      if (oSound._hasTimer) {\n        oSound._hasTimer = false;\n\n        if (!mobileHTML5 && sm2.html5PollingInterval) {\n          // interval will stop itself at next execution.\n          h5TimerCount--;\n        }\n      }\n    };\n\n    timerExecute = function () {\n      /**\r\n       * manual polling for HTML5 progress events, ie., whileplaying()\r\n       * (can achieve greater precision than conservative default HTML5 interval)\r\n       */\n      var i;\n\n      if (h5IntervalTimer !== null && !h5TimerCount) {\n        // no active timers, stop polling interval.\n        clearInterval(h5IntervalTimer);\n        h5IntervalTimer = null;\n        return;\n      } // check all HTML5 sounds with timers\n\n\n      for (i = sm2.soundIDs.length - 1; i >= 0; i--) {\n        if (sm2.sounds[sm2.soundIDs[i]].isHTML5 && sm2.sounds[sm2.soundIDs[i]]._hasTimer) {\n          sm2.sounds[sm2.soundIDs[i]]._onTimer();\n        }\n      }\n    };\n\n    catchError = function (options) {\n      options = options !== _undefined ? options : {};\n\n      if (typeof sm2.onerror === 'function') {\n        sm2.onerror.apply(window, [{\n          type: options.type !== _undefined ? options.type : null\n        }]);\n      }\n\n      if (options.fatal !== _undefined && options.fatal) {\n        sm2.disable();\n      }\n    };\n\n    badSafariFix = function () {\n      // special case: \"bad\" Safari (OS X 10.3 - 10.7) must fall back to flash for MP3/MP4\n      if (!isBadSafari || !detectFlash()) {\n        // doesn't apply\n        return;\n      }\n\n      var aF = sm2.audioFormats,\n          i,\n          item;\n\n      for (item in aF) {\n        if (aF.hasOwnProperty(item)) {\n          if (item === 'mp3' || item === 'mp4') {\n            sm2._wD(sm + ': Using flash fallback for ' + item + ' format');\n\n            sm2.html5[item] = false; // assign result to related formats, too\n\n            if (aF[item] && aF[item].related) {\n              for (i = aF[item].related.length - 1; i >= 0; i--) {\n                sm2.html5[aF[item].related[i]] = false;\n              }\n            }\n          }\n        }\n      }\n    };\n    /**\r\n     * Pseudo-private flash/ExternalInterface methods\r\n     * ----------------------------------------------\r\n     */\n\n\n    this._setSandboxType = function (sandboxType) {\n      // <d>\n      // Security sandbox according to Flash plugin\n      var sb = sm2.sandbox;\n      sb.type = sandboxType;\n      sb.description = sb.types[sb.types[sandboxType] !== _undefined ? sandboxType : 'unknown'];\n\n      if (sb.type === 'localWithFile') {\n        sb.noRemote = true;\n        sb.noLocal = false;\n\n        _wDS('secNote', 2);\n      } else if (sb.type === 'localWithNetwork') {\n        sb.noRemote = false;\n        sb.noLocal = true;\n      } else if (sb.type === 'localTrusted') {\n        sb.noRemote = false;\n        sb.noLocal = false;\n      } // </d>\n\n    };\n\n    this._externalInterfaceOK = function (swfVersion) {\n      // flash callback confirming flash loaded, EI working etc.\n      // swfVersion: SWF build string\n      if (sm2.swfLoaded) {\n        return;\n      }\n\n      var e;\n      debugTS('swf', true);\n      debugTS('flashtojs', true);\n      sm2.swfLoaded = true;\n      tryInitOnFocus = false;\n\n      if (isBadSafari) {\n        badSafariFix();\n      } // complain if JS + SWF build/version strings don't match, excluding +DEV builds\n      // <d>\n\n\n      if (!swfVersion || swfVersion.replace(/\\+dev/i, '') !== sm2.versionNumber.replace(/\\+dev/i, '')) {\n        e = sm + ': Fatal: JavaScript file build \"' + sm2.versionNumber + '\" does not match Flash SWF build \"' + swfVersion + '\" at ' + sm2.url + '. Ensure both are up-to-date.'; // escape flash -> JS stack so this error fires in window.\n\n        setTimeout(function () {\n          throw new Error(e);\n        }, 0); // exit, init will fail with timeout\n\n        return;\n      } // </d>\n      // IE needs a larger timeout\n\n\n      setTimeout(init, isIE ? 100 : 1);\n    };\n    /**\r\n     * Private initialization helpers\r\n     * ------------------------------\r\n     */\n\n\n    createMovie = function (movieID, movieURL) {\n      // ignore if already connected\n      if (didAppend && appendSuccess) return false;\n\n      function initMsg() {\n        // <d>\n        var options = [],\n            title,\n            msg = [],\n            delimiter = ' + ';\n        title = 'SoundManager ' + sm2.version + (!sm2.html5Only && sm2.useHTML5Audio ? sm2.hasHTML5 ? ' + HTML5 audio' : ', no HTML5 audio support' : '');\n\n        if (!sm2.html5Only) {\n          if (sm2.preferFlash) {\n            options.push('preferFlash');\n          }\n\n          if (sm2.useHighPerformance) {\n            options.push('useHighPerformance');\n          }\n\n          if (sm2.flashPollingInterval) {\n            options.push('flashPollingInterval (' + sm2.flashPollingInterval + 'ms)');\n          }\n\n          if (sm2.html5PollingInterval) {\n            options.push('html5PollingInterval (' + sm2.html5PollingInterval + 'ms)');\n          }\n\n          if (sm2.wmode) {\n            options.push('wmode (' + sm2.wmode + ')');\n          }\n\n          if (sm2.debugFlash) {\n            options.push('debugFlash');\n          }\n\n          if (sm2.useFlashBlock) {\n            options.push('flashBlock');\n          }\n        } else if (sm2.html5PollingInterval) {\n          options.push('html5PollingInterval (' + sm2.html5PollingInterval + 'ms)');\n        }\n\n        if (options.length) {\n          msg = msg.concat([options.join(delimiter)]);\n        }\n\n        sm2._wD(title + (msg.length ? delimiter + msg.join(', ') : ''), 1);\n\n        showSupport(); // </d>\n      }\n\n      if (sm2.html5Only) {\n        // 100% HTML5 mode\n        setVersionInfo();\n        initMsg();\n        sm2.oMC = id(sm2.movieID);\n        init(); // prevent multiple init attempts\n\n        didAppend = true;\n        appendSuccess = true;\n        return false;\n      } // flash path\n\n\n      var remoteURL = movieURL || sm2.url,\n          localURL = sm2.altURL || remoteURL,\n          swfTitle = 'JS/Flash audio component (SoundManager 2)',\n          oTarget = getDocument(),\n          extraClass = getSWFCSS(),\n          isRTL = null,\n          html = doc.getElementsByTagName('html')[0],\n          oEmbed,\n          oMovie,\n          tmp,\n          movieHTML,\n          oEl,\n          s,\n          x,\n          sClass;\n      isRTL = html && html.dir && html.dir.match(/rtl/i);\n      movieID = movieID === _undefined ? sm2.id : movieID;\n\n      function param(name, value) {\n        return '<param name=\"' + name + '\" value=\"' + value + '\" />';\n      } // safety check for legacy (change to Flash 9 URL)\n\n\n      setVersionInfo();\n      sm2.url = normalizeMovieURL(overHTTP ? remoteURL : localURL);\n      movieURL = sm2.url;\n      sm2.wmode = !sm2.wmode && sm2.useHighPerformance ? 'transparent' : sm2.wmode;\n\n      if (sm2.wmode !== null && (ua.match(/msie 8/i) || !isIE && !sm2.useHighPerformance) && navigator.platform.match(/win32|win64/i)) {\n        /**\r\n         * extra-special case: movie doesn't load until scrolled into view when using wmode = anything but 'window' here\r\n         * does not apply when using high performance (position:fixed means on-screen), OR infinite flash load timeout\r\n         * wmode breaks IE 8 on Vista + Win7 too in some cases, as of January 2011 (?)\r\n         */\n        messages.push(strings.spcWmode);\n        sm2.wmode = null;\n      }\n\n      oEmbed = {\n        name: movieID,\n        id: movieID,\n        src: movieURL,\n        quality: 'high',\n        allowScriptAccess: sm2.allowScriptAccess,\n        bgcolor: sm2.bgColor,\n        pluginspage: http + 'www.macromedia.com/go/getflashplayer',\n        title: swfTitle,\n        type: 'application/x-shockwave-flash',\n        wmode: sm2.wmode,\n        // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html\n        hasPriority: 'true'\n      };\n\n      if (sm2.debugFlash) {\n        oEmbed.FlashVars = 'debug=1';\n      }\n\n      if (!sm2.wmode) {\n        // don't write empty attribute\n        delete oEmbed.wmode;\n      }\n\n      if (isIE) {\n        // IE is \"special\".\n        oMovie = doc.createElement('div');\n        movieHTML = ['<object id=\"' + movieID + '\" data=\"' + movieURL + '\" type=\"' + oEmbed.type + '\" title=\"' + oEmbed.title + '\" classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0\">', param('movie', movieURL), param('AllowScriptAccess', sm2.allowScriptAccess), param('quality', oEmbed.quality), sm2.wmode ? param('wmode', sm2.wmode) : '', param('bgcolor', sm2.bgColor), param('hasPriority', 'true'), sm2.debugFlash ? param('FlashVars', oEmbed.FlashVars) : '', '</object>'].join('');\n      } else {\n        oMovie = doc.createElement('embed');\n\n        for (tmp in oEmbed) {\n          if (oEmbed.hasOwnProperty(tmp)) {\n            oMovie.setAttribute(tmp, oEmbed[tmp]);\n          }\n        }\n      }\n\n      initDebug();\n      extraClass = getSWFCSS();\n      oTarget = getDocument();\n\n      if (oTarget) {\n        sm2.oMC = id(sm2.movieID) || doc.createElement('div');\n\n        if (!sm2.oMC.id) {\n          sm2.oMC.id = sm2.movieID;\n          sm2.oMC.className = swfCSS.swfDefault + ' ' + extraClass;\n          s = null;\n          oEl = null;\n\n          if (!sm2.useFlashBlock) {\n            if (sm2.useHighPerformance) {\n              // on-screen at all times\n              s = {\n                position: 'fixed',\n                width: '8px',\n                height: '8px',\n                // >= 6px for flash to run fast, >= 8px to start up under Firefox/win32 in some cases. odd? yes.\n                bottom: '0px',\n                left: '0px',\n                overflow: 'hidden'\n              };\n            } else {\n              // hide off-screen, lower priority\n              s = {\n                position: 'absolute',\n                width: '6px',\n                height: '6px',\n                top: '-9999px',\n                left: '-9999px'\n              };\n\n              if (isRTL) {\n                s.left = Math.abs(parseInt(s.left, 10)) + 'px';\n              }\n            }\n          }\n\n          if (isWebkit) {\n            // soundcloud-reported render/crash fix, safari 5\n            sm2.oMC.style.zIndex = 10000;\n          }\n\n          if (!sm2.debugFlash) {\n            for (x in s) {\n              if (s.hasOwnProperty(x)) {\n                sm2.oMC.style[x] = s[x];\n              }\n            }\n          }\n\n          try {\n            if (!isIE) {\n              sm2.oMC.appendChild(oMovie);\n            }\n\n            oTarget.appendChild(sm2.oMC);\n\n            if (isIE) {\n              oEl = sm2.oMC.appendChild(doc.createElement('div'));\n              oEl.className = swfCSS.swfBox;\n              oEl.innerHTML = movieHTML;\n            }\n\n            appendSuccess = true;\n          } catch (e) {\n            throw new Error(str('domError') + ' \\n' + e.toString());\n          }\n        } else {\n          // SM2 container is already in the document (eg. flashblock use case)\n          sClass = sm2.oMC.className;\n          sm2.oMC.className = (sClass ? sClass + ' ' : swfCSS.swfDefault) + (extraClass ? ' ' + extraClass : '');\n          sm2.oMC.appendChild(oMovie);\n\n          if (isIE) {\n            oEl = sm2.oMC.appendChild(doc.createElement('div'));\n            oEl.className = swfCSS.swfBox;\n            oEl.innerHTML = movieHTML;\n          }\n\n          appendSuccess = true;\n        }\n      }\n\n      didAppend = true;\n      initMsg(); // sm2._wD(sm + ': Trying to load ' + movieURL + (!overHTTP && sm2.altURL ? ' (alternate URL)' : ''), 1);\n\n      return true;\n    };\n\n    initMovie = function () {\n      if (sm2.html5Only) {\n        createMovie();\n        return false;\n      } // attempt to get, or create, movie (may already exist)\n\n\n      if (flash) return false;\n\n      if (!sm2.url) {\n        /**\r\n         * Something isn't right - we've reached init, but the soundManager url property has not been set.\r\n         * User has not called setup({url: ...}), or has not set soundManager.url (legacy use case) directly before init time.\r\n         * Notify and exit. If user calls setup() with a url: property, init will be restarted as in the deferred loading case.\r\n         */\n        _wDS('noURL');\n\n        return false;\n      } // inline markup case\n\n\n      flash = sm2.getMovie(sm2.id);\n\n      if (!flash) {\n        if (!oRemoved) {\n          // try to create\n          createMovie(sm2.id, sm2.url);\n        } else {\n          // try to re-append removed movie after reboot()\n          if (!isIE) {\n            sm2.oMC.appendChild(oRemoved);\n          } else {\n            sm2.oMC.innerHTML = oRemovedHTML;\n          }\n\n          oRemoved = null;\n          didAppend = true;\n        }\n\n        flash = sm2.getMovie(sm2.id);\n      }\n\n      if (typeof sm2.oninitmovie === 'function') {\n        setTimeout(sm2.oninitmovie, 1);\n      } // <d>\n\n\n      flushMessages(); // </d>\n\n      return true;\n    };\n\n    delayWaitForEI = function () {\n      setTimeout(waitForEI, 1000);\n    };\n\n    rebootIntoHTML5 = function () {\n      // special case: try for a reboot with preferFlash: false, if 100% HTML5 mode is possible and useFlashBlock is not enabled.\n      window.setTimeout(function () {\n        complain(smc + 'useFlashBlock is false, 100% HTML5 mode is possible. Rebooting with preferFlash: false...');\n        sm2.setup({\n          preferFlash: false\n        }).reboot(); // if for some reason you want to detect this case, use an ontimeout() callback and look for html5Only and didFlashBlock == true.\n\n        sm2.didFlashBlock = true;\n        sm2.beginDelayedInit();\n      }, 1);\n    };\n\n    waitForEI = function () {\n      var p,\n          loadIncomplete = false;\n\n      if (!sm2.url) {\n        // No SWF url to load (noURL case) - exit for now. Will be retried when url is set.\n        return;\n      }\n\n      if (waitingForEI) {\n        return;\n      }\n\n      waitingForEI = true;\n      event.remove(window, 'load', delayWaitForEI);\n\n      if (hasFlash && tryInitOnFocus && !isFocused) {\n        // Safari won't load flash in background tabs, only when focused.\n        _wDS('waitFocus');\n\n        return;\n      }\n\n      if (!didInit) {\n        p = sm2.getMoviePercent();\n\n        if (p > 0 && p < 100) {\n          loadIncomplete = true;\n        }\n      }\n\n      setTimeout(function () {\n        p = sm2.getMoviePercent();\n\n        if (loadIncomplete) {\n          // special case: if movie *partially* loaded, retry until it's 100% before assuming failure.\n          waitingForEI = false;\n\n          sm2._wD(str('waitSWF'));\n\n          window.setTimeout(delayWaitForEI, 1);\n          return;\n        } // <d>\n\n\n        if (!didInit) {\n          sm2._wD(sm + ': No Flash response within expected time. Likely causes: ' + (p === 0 ? 'SWF load failed, ' : '') + 'Flash blocked or JS-Flash security error.' + (sm2.debugFlash ? ' ' + str('checkSWF') : ''), 2);\n\n          if (!overHTTP && p) {\n            _wDS('localFail', 2);\n\n            if (!sm2.debugFlash) {\n              _wDS('tryDebug', 2);\n            }\n          }\n\n          if (p === 0) {\n            // if 0 (not null), probably a 404.\n            sm2._wD(str('swf404', sm2.url), 1);\n          }\n\n          debugTS('flashtojs', false, ': Timed out' + (overHTTP ? ' (Check flash security or flash blockers)' : ' (No plugin/missing SWF?)'));\n        } // </d>\n        // give up / time-out, depending\n\n\n        if (!didInit && okToDisable) {\n          if (p === null) {\n            // SWF failed to report load progress. Possibly blocked.\n            if (sm2.useFlashBlock || sm2.flashLoadTimeout === 0) {\n              if (sm2.useFlashBlock) {\n                flashBlockHandler();\n              }\n\n              _wDS('waitForever');\n            } else if (!sm2.useFlashBlock && canIgnoreFlash) {\n              // no custom flash block handling, but SWF has timed out. Will recover if user unblocks / allows SWF load.\n              rebootIntoHTML5();\n            } else {\n              _wDS('waitForever'); // fire any regular registered ontimeout() listeners.\n\n\n              processOnEvents({\n                type: 'ontimeout',\n                ignoreInit: true,\n                error: {\n                  type: 'INIT_FLASHBLOCK'\n                }\n              });\n            }\n          } else if (sm2.flashLoadTimeout === 0) {\n            // SWF loaded? Shouldn't be a blocking issue, then.\n            _wDS('waitForever');\n          } else if (!sm2.useFlashBlock && canIgnoreFlash) {\n            rebootIntoHTML5();\n          } else {\n            failSafely(true);\n          }\n        }\n      }, sm2.flashLoadTimeout);\n    };\n\n    handleFocus = function () {\n      function cleanup() {\n        event.remove(window, 'focus', handleFocus);\n      }\n\n      if (isFocused || !tryInitOnFocus) {\n        // already focused, or not special Safari background tab case\n        cleanup();\n        return true;\n      }\n\n      okToDisable = true;\n      isFocused = true;\n\n      _wDS('gotFocus'); // allow init to restart\n\n\n      waitingForEI = false; // kick off ExternalInterface timeout, now that the SWF has started\n\n      delayWaitForEI();\n      cleanup();\n      return true;\n    };\n\n    flushMessages = function () {\n      // <d>\n      // SM2 pre-init debug messages\n      if (messages.length) {\n        sm2._wD('SoundManager 2: ' + messages.join(' '), 1);\n\n        messages = [];\n      } // </d>\n\n    };\n\n    showSupport = function () {\n      // <d>\n      flushMessages();\n      var item,\n          tests = [];\n\n      if (sm2.useHTML5Audio && sm2.hasHTML5) {\n        for (item in sm2.audioFormats) {\n          if (sm2.audioFormats.hasOwnProperty(item)) {\n            tests.push(item + ' = ' + sm2.html5[item] + (!sm2.html5[item] && needsFlash && sm2.flash[item] ? ' (using flash)' : sm2.preferFlash && sm2.flash[item] && needsFlash ? ' (preferring flash)' : !sm2.html5[item] ? ' (' + (sm2.audioFormats[item].required ? 'required, ' : '') + 'and no flash support)' : ''));\n          }\n        }\n\n        sm2._wD('SoundManager 2 HTML5 support: ' + tests.join(', '), 1);\n      } // </d>\n\n    };\n\n    initComplete = function (bNoDisable) {\n      if (didInit) return false;\n\n      if (sm2.html5Only) {\n        // all good.\n        _wDS('sm2Loaded', 1);\n\n        didInit = true;\n        initUserOnload();\n        debugTS('onload', true);\n        return true;\n      }\n\n      var wasTimeout = sm2.useFlashBlock && sm2.flashLoadTimeout && !sm2.getMoviePercent(),\n          result = true,\n          error;\n\n      if (!wasTimeout) {\n        didInit = true;\n      }\n\n      error = {\n        type: !hasFlash && needsFlash ? 'NO_FLASH' : 'INIT_TIMEOUT'\n      };\n\n      sm2._wD('SoundManager 2 ' + (disabled ? 'failed to load' : 'loaded') + ' (' + (disabled ? 'Flash security/load error' : 'OK') + ') ' + String.fromCharCode(disabled ? 10006 : 10003), disabled ? 2 : 1);\n\n      if (disabled || bNoDisable) {\n        if (sm2.useFlashBlock && sm2.oMC) {\n          sm2.oMC.className = getSWFCSS() + ' ' + (sm2.getMoviePercent() === null ? swfCSS.swfTimedout : swfCSS.swfError);\n        }\n\n        processOnEvents({\n          type: 'ontimeout',\n          error: error,\n          ignoreInit: true\n        });\n        debugTS('onload', false);\n        catchError(error);\n        result = false;\n      } else {\n        debugTS('onload', true);\n      }\n\n      if (!disabled) {\n        if (sm2.waitForWindowLoad && !windowLoaded) {\n          _wDS('waitOnload');\n\n          event.add(window, 'load', initUserOnload);\n        } else {\n          // <d>\n          if (sm2.waitForWindowLoad && windowLoaded) {\n            _wDS('docLoaded');\n          } // </d>\n\n\n          initUserOnload();\n        }\n      }\n\n      return result;\n    };\n    /**\r\n     * apply top-level setupOptions object as local properties, eg., this.setupOptions.flashVersion -> this.flashVersion (soundManager.flashVersion)\r\n     * this maintains backward compatibility, and allows properties to be defined separately for use by soundManager.setup().\r\n     */\n\n\n    setProperties = function () {\n      var i,\n          o = sm2.setupOptions;\n\n      for (i in o) {\n        if (o.hasOwnProperty(i)) {\n          // assign local property if not already defined\n          if (sm2[i] === _undefined) {\n            sm2[i] = o[i];\n          } else if (sm2[i] !== o[i]) {\n            // legacy support: write manually-assigned property (eg., soundManager.url) back to setupOptions to keep things in sync\n            sm2.setupOptions[i] = sm2[i];\n          }\n        }\n      }\n    };\n\n    init = function () {\n      // called after onload()\n      if (didInit) {\n        _wDS('didInit');\n\n        return false;\n      }\n\n      function cleanup() {\n        event.remove(window, 'load', sm2.beginDelayedInit);\n      }\n\n      if (sm2.html5Only) {\n        if (!didInit) {\n          // we don't need no steenking flash!\n          cleanup();\n          sm2.enabled = true;\n          initComplete();\n        }\n\n        return true;\n      } // flash path\n\n\n      initMovie();\n\n      try {\n        // attempt to talk to Flash\n        flash._externalInterfaceTest(false);\n        /**\r\n         * Apply user-specified polling interval, OR, if \"high performance\" set, faster vs. default polling\r\n         * (determines frequency of whileloading/whileplaying callbacks, effectively driving UI framerates)\r\n         */\n\n\n        setPolling(true, sm2.flashPollingInterval || (sm2.useHighPerformance ? 10 : 50));\n\n        if (!sm2.debugMode) {\n          // stop the SWF from making debug output calls to JS\n          flash._disableDebug();\n        }\n\n        sm2.enabled = true;\n        debugTS('jstoflash', true);\n\n        if (!sm2.html5Only) {\n          // prevent browser from showing cached page state (or rather, restoring \"suspended\" page state) via back button, because flash may be dead\n          // http://www.webkit.org/blog/516/webkit-page-cache-ii-the-unload-event/\n          event.add(window, 'unload', doNothing);\n        }\n      } catch (e) {\n        sm2._wD('js/flash exception: ' + e.toString());\n\n        debugTS('jstoflash', false);\n        catchError({\n          type: 'JS_TO_FLASH_EXCEPTION',\n          fatal: true\n        }); // don't disable, for reboot()\n\n        failSafely(true);\n        initComplete();\n        return false;\n      }\n\n      initComplete(); // disconnect events\n\n      cleanup();\n      return true;\n    };\n\n    domContentLoaded = function () {\n      if (didDCLoaded) return false;\n      didDCLoaded = true; // assign top-level soundManager properties eg. soundManager.url\n\n      setProperties();\n      initDebug();\n\n      if (!hasFlash && sm2.hasHTML5) {\n        sm2._wD('SoundManager 2: No Flash detected' + (!sm2.useHTML5Audio ? ', enabling HTML5.' : '. Trying HTML5-only mode.'), 1);\n\n        sm2.setup({\n          useHTML5Audio: true,\n          // make sure we aren't preferring flash, either\n          // TODO: preferFlash should not matter if flash is not installed. Currently, stuff breaks without the below tweak.\n          preferFlash: false\n        });\n      }\n\n      testHTML5();\n\n      if (!hasFlash && needsFlash) {\n        messages.push(strings.needFlash); // TODO: Fatal here vs. timeout approach, etc.\n        // hack: fail sooner.\n\n        sm2.setup({\n          flashLoadTimeout: 1\n        });\n      }\n\n      if (doc.removeEventListener) {\n        doc.removeEventListener('DOMContentLoaded', domContentLoaded, false);\n      }\n\n      initMovie();\n      return true;\n    };\n\n    domContentLoadedIE = function () {\n      if (doc.readyState === 'complete') {\n        domContentLoaded();\n        doc.detachEvent('onreadystatechange', domContentLoadedIE);\n      }\n\n      return true;\n    };\n\n    winOnLoad = function () {\n      // catch edge case of initComplete() firing after window.load()\n      windowLoaded = true; // catch case where DOMContentLoaded has been sent, but we're still in doc.readyState = 'interactive'\n\n      domContentLoaded();\n      event.remove(window, 'load', winOnLoad);\n    }; // sniff up-front\n\n\n    detectFlash(); // focus and window load, init (primarily flash-driven)\n\n    event.add(window, 'focus', handleFocus);\n    event.add(window, 'load', delayWaitForEI);\n    event.add(window, 'load', winOnLoad);\n\n    if (doc.addEventListener) {\n      doc.addEventListener('DOMContentLoaded', domContentLoaded, false);\n    } else if (doc.attachEvent) {\n      doc.attachEvent('onreadystatechange', domContentLoadedIE);\n    } else {\n      // no add/attachevent support - safe to assume no JS -> Flash either\n      debugTS('onload', false);\n      catchError({\n        type: 'NO_DOM2_EVENTS',\n        fatal: true\n      });\n    }\n  } // SoundManager()\n  // SM2_DEFER details: http://www.schillmania.com/projects/soundmanager2/doc/getstarted/#lazy-loading\n\n\n  if (window.SM2_DEFER === _undefined || !SM2_DEFER) {\n    soundManager = new SoundManager();\n  }\n  /**\r\n   * SoundManager public interfaces\r\n   * ------------------------------\r\n   */\n\n\n  if (typeof module === 'object' && module && typeof module.exports === 'object') {\n    /**\r\n     * commonJS module\r\n     */\n    module.exports.SoundManager = SoundManager;\n    module.exports.soundManager = soundManager;\n  } else if (typeof define === 'function' && define.amd) {\n    /**\r\n     * AMD - requireJS\r\n     * basic usage:\r\n     * require([\"/path/to/soundmanager2.js\"], function(SoundManager) {\r\n     *   SoundManager.getInstance().setup({\r\n     *     url: '/swf/',\r\n     *     onready: function() { ... }\r\n     *   })\r\n     * });\r\n     *\r\n     * SM2_DEFER usage:\r\n     * window.SM2_DEFER = true;\r\n     * require([\"/path/to/soundmanager2.js\"], function(SoundManager) {\r\n     *   SoundManager.getInstance(function() {\r\n     *     var soundManager = new SoundManager.constructor();\r\n     *     soundManager.setup({\r\n     *       url: '/swf/',\r\n     *       ...\r\n     *     });\r\n     *     ...\r\n     *     soundManager.beginDelayedInit();\r\n     *     return soundManager;\r\n     *   })\r\n     * });\r\n     */\n    define(function () {\n      /**\r\n       * Retrieve the global instance of SoundManager.\r\n       * If a global instance does not exist it can be created using a callback.\r\n       *\r\n       * @param {Function} smBuilder Optional: Callback used to create a new SoundManager instance\r\n       * @return {SoundManager} The global SoundManager instance\r\n       */\n      function getInstance(smBuilder) {\n        if (!window.soundManager && smBuilder instanceof Function) {\n          var instance = smBuilder(SoundManager);\n\n          if (instance instanceof SoundManager) {\n            window.soundManager = instance;\n          }\n        }\n\n        return window.soundManager;\n      }\n\n      return {\n        constructor: SoundManager,\n        getInstance: getInstance\n      };\n    });\n  } // standard browser case\n  // constructor\n\n\n  window.SoundManager = SoundManager;\n  /**\r\n   * note: SM2 requires a window global due to Flash, which makes calls to window.soundManager.\r\n   * Flash may not always be needed, but this is not known until async init and SM2 may even \"reboot\" into Flash mode.\r\n   */\n  // public API, flash callbacks etc.\n\n  window.soundManager = soundManager;\n})(window);","map":null,"metadata":{},"sourceType":"script"}